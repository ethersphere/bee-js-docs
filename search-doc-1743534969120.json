{"searchDocs":[{"title":"Bee JS - The Swarm JS Library","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"","version":"Next"},{"title":"Development‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#development","content":"We'd love you to join us! Are you up to the challenge of helping us to create bee-js and the other incredible technologies we're building? Have a look at our Github - Ethersphere. ","version":"Next","tagName":"h2"},{"title":"Community‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#community","content":"There is a vibrant and buzzing community behind Swarm, get involved in one of our group channels. Official Swarm websiteDiscord roomTwitter @ethswarmReddit channel ","version":"Next","tagName":"h2"},{"title":"Reporting a bug‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#reporting-a-bug","content":"If anything isn't working, get in touch and let us know! Every Bee is important to us and we'll get right to work on fixing it for you as soon as possible. üêù ","version":"Next","tagName":"h2"},{"title":"Examples‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#examples","content":"We have repo with some examples that might be interesting for you to see. Check it out here. ","version":"Next","tagName":"h2"},{"title":"ACT (Access Control Trie)","type":0,"sectionRef":"#","url":"/docs/act/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"ACT (Access Control Trie)","url":"/docs/act/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Show example of creating grantee listShow example of secure uploadShow example of secure download ","version":"Next","tagName":"h2"},{"title":"GSOC","type":0,"sectionRef":"#","url":"/docs/gsoc/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"GSOC","url":"/docs/gsoc/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Show mining the writer private key for the targeted overlay address GistShow a simple listener, and a simple send invocation Gist1 Gist2Show Identifier class usage Gist ","version":"Next","tagName":"h2"},{"title":"Manifests","type":0,"sectionRef":"#","url":"/docs/manifests/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"Manifests","url":"/docs/manifests/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Intro on what Manifests (a.k.a Mantaray nodes) areShow an example of loading manifests GistShow an example of working with loaded manifestsShow creating a manifest from zero, working with it, saving ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/getting-started/","content":"","keywords":"","version":"Next"},{"title":"About bee-js‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#about-bee-js","content":"bee-js simplifies development on Swarm by abstracting away many of finer details and quirks of the Bee API so that you can focus on building your dream DAPP with minimal hassle. It's the easiest way to get started developing on Swarm. ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#installation","content":"npmyarnscript tag npm install @ethersphere/bee-js --save  After that you need to import the Bee class and create a bee instance connecting to your Bee node (here we assume it runs on localhost on default port). Be aware, if you will pass invalid URL the constructor will throw an exception! import { Bee } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633')  That‚Äôs it! now you can use the bee object. Run your own Bee node You can find out more about running Bee node in the Bee docs Using &lt;script&gt; import If you include bee-js using the unpkg.com script link then all the exported components will be available to you under global namespace BeeJs: &lt;script src=&quot;https://unpkg.com/@ethersphere/bee-js/dist/index.browser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const bee = new BeeJs.Bee('...') &lt;/script&gt;  ","version":"Next","tagName":"h2"},{"title":"Quickstart With create-swarm-app‚Äã","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#quickstart-with-create-swarm-app","content":"The create-swarm-app tool makes it easy to get started developing on Swarm. With a single command, it generates the basic scaffolding for a bee-js project in your chosen development environment (CommonJS, ESM, TypeScript, or Vite + TypeScript). WSL WARNING The create-swarm-app tool is compatible with Windows, macOS, and Linux. However, using it in combination with WSL is discouraged due to potential compatibility issues that may require additional troubleshooting. That said, the bee-js library itself works seamlessly within WSL. If you prefer to develop your project using WSL, you can use create-swarm-app to generate the project files on the Windows side, then move them into your WSL environment for development. You can use create-swarm-app to quickly set up scaffolding for a bee-js project with the following command: npm init swarm-app@latest {app-name} {app-type}  Replace &quot;{app-name}&quot; with your app's name, and &quot;{app-type}&quot; with the type of app you want. Supported types are node, node-esm, node-ts and vite-tsx. Start a Swarm project using TypeScript: npm init swarm-app@latest my-dapp node-ts  Your project structure will look like: . ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ config.ts ‚îÇ ‚îî‚îÄ‚îÄ index.ts ‚îî‚îÄ‚îÄ tsconfig.json  or using Vite and TypeScript: npm init swarm-app@latest my-dapp vite-tsx  Your project structure will look like: tree . . ‚îú‚îÄ‚îÄ index.html ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ App.tsx ‚îÇ ‚îú‚îÄ‚îÄ config.ts ‚îÇ ‚îî‚îÄ‚îÄ index.tsx ‚îî‚îÄ‚îÄ tsconfig.json  The exact results will differ slightly depending on which {app-type} you use, but they will all include a config.ts or config.js file where the Bee node's API endpoint must be specified. The endpoint is set to the default Bee API endpoint of http://localhost:1633, if your node uses a different endpoint you will need to update it in the config file. ","version":"Next","tagName":"h2"},{"title":"Pinning","type":0,"sectionRef":"#","url":"/docs/pinning/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"Pinning","url":"/docs/pinning/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Show an example of pinning a referenceShow an example of listing referencesShow an example of re-uploading a reference ","version":"Next","tagName":"h2"},{"title":"Community","type":0,"sectionRef":"#","url":"/docs/resources/community/","content":"Community try-out-swarm - a quick bootstrap for Swarm including shell scripts for Bee and typescript scripts using bee-js","keywords":"","version":"Next"},{"title":"Chequebook and Cheques","type":0,"sectionRef":"#","url":"/docs/chequebook/","content":"Chequebook and Cheques Get chequebook balanceWithdraw from chequebook to node walletDeposit to chequebook from node walletGet chequesCashout cheque","keywords":"","version":"Next"},{"title":"SDK Overview","type":0,"sectionRef":"#","url":"/docs/overview/","content":"","keywords":"","version":"Next"},{"title":"Type interfaces‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#type-interfaces","content":"NumberString is a branded type for marking strings that represent numbers. It interops with string and biginttypes. Where NumberString is present, number is disallowed in order to avoid pitfalls with unsafe large values. ","version":"Next","tagName":"h3"},{"title":"Byte primitives‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#byte-primitives","content":"All the classes below extend Bytes, therefor the following methods are available on all of them: toUint8Array,toHex, toBase64, toBase32, toUtf8, toJSON, static keccak256, static fromUtf8. The toString method uses toHex. Bytes and its subclasses may be constructed with new from Uint8Array or hex string. Elliptic‚Äã Name\tDescription\tMethodsPrivateKey\t32 bytes private key\tpublicKey, sign PublicKey\t64 bytes public key\taddress, toCompressedUint8Array, toCompressedHex EthAddress\t20 bytes Ethereum address\ttoChecksum Signature\t65 bytes signature\trecoverPublicKey Swarm‚Äã Name\tDescription\tMethodsReference\t32/64 bytes reference (chunk, feed)\ttoCid Identifier\t32 bytes identifier (SOC, Feed)\t- TransactionId\t32 bytes transaction ID\t- FeedIndex\t8 bytes feed index (BE)\tstatic fromBigInt, toBigInt Topic\t32 bytes topic\tstatic fromString PeerAddress\t32 bytes peer address\t- BatchId\t32 bytes batch ID\t- Span\t8 bytes span (LE)\tstatic fromBigInt, toBigInt ","version":"Next","tagName":"h3"},{"title":"Tokens‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#tokens","content":"Name\tDescription\tMethodsDAI\tERC20 DAI token (18 digits)\tstatic fromDecimalString, static fromWei, toWeiString, toWeiBigInt, toDecimalString BZZ\tERC20 BZZ token (16 digits)\tstatic fromDecimalString, static fromPLUR, toPLURString, toPLURBigInt, toDecimalString ","version":"Next","tagName":"h3"},{"title":"Swarm chunks‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#swarm-chunks","content":"Name\tDescription\tCreationChunk\tSpan, max. 4096 bytes payload; address dervied from content\tmakeContentAddressedChunk SingleOwnerChunk\tIdentifier, signature, span, max. 4096 bytes payload; address derived from identifier and owner\tmakeSingleOwnerChunk ","version":"Next","tagName":"h3"},{"title":"Swarm primitives‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#swarm-primitives","content":"Name\tDescription\tMethodsMantarayNode\tCompact trie with reference values and JSON metadata\taddFork, removeFork, calculateSelfAddress, find, findClosest, collect, marshal, unmarshal, saveRecursively, loadRecursively MerkleTree\tStreaming BMT of chunks\tappend, finalize, static root ","version":"Next","tagName":"h3"},{"title":"Swarm objects‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#swarm-objects","content":"Name\tDescription\tCreationSOCWriter\tSingleOwnerChunk writer\tbee.makeSOCWriter SOCReader\tSingleOwnerChunk reader\tbee.makeSOCReader FeedWriter\tFeed writer\tbee.makeFeedWriter FeedReader\tFeed reader\tbee.makeFeedReader ","version":"Next","tagName":"h3"},{"title":"Bee API‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#bee-api","content":"Each bee-js method corresponds to a particular endpoint from the API. The chart below maps each method to its corresponding API endpoint. Refer to the Bee API specifications for more details about each endpoint. It also specifies which node type is supported for each method/endpoint. ‚ùå‚ùå‚úÖ - Full node only‚ùå‚úÖ‚úÖ - Light node and full node‚úÖ‚úÖ‚úÖ - Ultra-light node, light node and full node JS Call\tBee Endpoint\tBee ModeuploadFile\tPOST /bzz üîó\t‚ùå‚úÖ‚úÖ uploadFilesFromDirectory Node.js\tPOST /bzz üîó\t‚ùå‚úÖ‚úÖ uploadFiles\tPOST /bzz üîó\t‚ùå‚úÖ‚úÖ uploadCollection\tPOST /bzz üîó\t‚ùå‚úÖ‚úÖ uploadData\tPOST /bytes üîó\t‚ùå‚úÖ‚úÖ uploadChunk\tPOST /chunks üîó\t‚ùå‚úÖ‚úÖ streamDirectory Node.js\tPOST /chunks üîó\t‚ùå‚úÖ‚úÖ streamFiles Browser\tPOST /chunks üîó\t‚ùå‚úÖ‚úÖ SOCWriter.upload\tPOST /soc/:owner/:identifier üîó\t‚ùå‚úÖ‚úÖ FeedReader.download\tGET /feeds/:owner/:topic üîó\t‚úÖ‚úÖ‚úÖ FeedWriter.updateFeed\tPOST /soc/:owner/:identifier üîó\t‚ùå‚úÖ‚úÖ downloadFile\tGET /bzz/:reference üîó\t‚úÖ‚úÖ‚úÖ downloadFile\tGET /bzz/:reference/:path üîó\t‚úÖ‚úÖ‚úÖ downloadReadableFile\tGET /bzz/:reference üîó\t‚úÖ‚úÖ‚úÖ downloadData\tGET /bytes/:reference üîó\t‚úÖ‚úÖ‚úÖ downloadReadableData\tGET /bytes/:reference üîó\t‚úÖ‚úÖ‚úÖ downloadChunk\tGET /chunks/:reference üîó\t‚úÖ‚úÖ‚úÖ createFeedManifest\tPOST /feeds/:owner/:topic üîó\t‚ùå‚úÖ‚úÖ isConnected\tGET /\t‚úÖ‚úÖ‚úÖ getHealth\tGET /health üîó\t‚úÖ‚úÖ‚úÖ getReadiness\tGET /readiness üîó\t‚úÖ‚úÖ‚úÖ getNodeInfo\tGET /node üîó\t‚úÖ‚úÖ‚úÖ getChainState\tGET /chainstate üîó\t‚ùå‚úÖ‚úÖ getRedistributionState\tGET /redistributionstate üîó\t‚ùå‚ùå‚úÖ getReserveState\tGET /reservestate üîó\t‚ùå‚ùå‚úÖ getStatus\tGET /status üîó\t‚úÖ‚úÖ‚úÖ getWallet\tGET /wallet üîó\t‚ùå‚úÖ‚úÖ getTopology\tGET /topology üîó\t‚úÖ‚úÖ‚úÖ getAddresses\tGET /addresses üîó\t‚úÖ‚úÖ‚úÖ getPeers\tGET /peers üîó\t‚úÖ‚úÖ‚úÖ getAllBalances\tGET /balances üîó\t‚ùå‚úÖ‚úÖ getPeerBalance\tGET /balances/:peer üîó\t‚ùå‚úÖ‚úÖ getPastDueConsumptionBalances\tGET /consumed üîó\t‚ùå‚úÖ‚úÖ getPastDueConsumptionPeerBalance\tGET /consumed/:peer üîó\t‚ùå‚úÖ‚úÖ getAllSettlements\tGET /settlements üîó\t‚ùå‚úÖ‚úÖ getSettlements\tGET /settlements/:peer üîó\t‚ùå‚úÖ‚úÖ getChequebookAddress\tGET /chequebook/address üîó\t‚ùå‚úÖ‚úÖ getChequebookBalance\tGET /chequebook/balance üîó\t‚ùå‚úÖ‚úÖ getLastCheques\tGET /chequebook/cheque üîó\t‚ùå‚úÖ‚úÖ getLastChequesForPeer\tGET /chequebook/cheque/:peer üîó\t‚ùå‚úÖ‚úÖ getLastCashoutAction\tGET /chequebook/cashout/:peer üîó\t‚ùå‚úÖ‚úÖ cashoutLastCheque\tPOST /chequebook/cashout/:peer üîó\t‚ùå‚úÖ‚úÖ depositTokens\tPOST /chequebook/deposit üîó\t‚ùå‚úÖ‚úÖ withdrawTokens\tPOST /chequebook/withdraw üîó\t‚ùå‚úÖ‚úÖ getAllPendingTransactions\tGET /transactions üîó\t‚ùå‚úÖ‚úÖ getPendingTransaction\tGET /transactions/:id üîó\t‚ùå‚úÖ‚úÖ rebroadcastTransaction\tPOST /transactions/:id üîó\t‚ùå‚úÖ‚úÖ cancelTransaction\tDELETE /transactions/:id üîó\t‚ùå‚úÖ‚úÖ createTag\tPOST /tags üîó\t‚ùå‚úÖ‚úÖ retrieveTag\tGET /tags/:id üîó\t‚ùå‚úÖ‚úÖ getAllTags\tGET /tags üîó\t‚ùå‚úÖ‚úÖ deleteTag\tDELETE /tags/:id üîó\t‚ùå‚úÖ‚úÖ updateTag\tPATCH /tags/:id üîó\t‚ùå‚úÖ‚úÖ pin\tPOST /pins/:reference üîó\t‚úÖ‚úÖ‚úÖ getAllPins\tGET /pins üîó\t‚úÖ‚úÖ‚úÖ getPin\tGET /pins/:reference üîó\t‚úÖ‚úÖ‚úÖ isReferenceRetrievable\tGET /stewardship/:reference üîó\t‚úÖ‚úÖ‚úÖ reuploadPinnedData\tPUT /stewardship/:reference üîó\t‚ùå‚úÖ‚úÖ unpin\tDELETE /pins/:reference üîó\t‚úÖ‚úÖ‚úÖ getGrantees\tGET /grantee/:reference üîó\t‚ùå‚úÖ‚úÖ createGrantees\tPOST /grantee üîó\t‚ùå‚úÖ‚úÖ patchGrantees\tPATCH /grantee/:reference üîó\t‚ùå‚úÖ‚úÖ pssSend\tPOST /pss/send/:topic/:target üîó\t‚ùå‚úÖ‚úÖ pssSubscribe Websocket\tGET /pss/subscribe/:topic üîó\t‚ùå‚ùå‚úÖ pssReceive\tGET /pss/subscribe/:topic üîó\t‚ùå‚ùå‚úÖ getAllPostageBatch\tGET /stamps üîó\t‚ùå‚úÖ‚úÖ getGlobalPostageBatches\tGET /batches üîó\t‚ùå‚úÖ‚úÖ getPostageBatch\tGET /stamps/:batchId üîó\t‚ùå‚úÖ‚úÖ getPostageBatchBuckets\tGET /stamps/:batchId/buckets üîó\t‚ùå‚úÖ‚úÖ createPostageBatch\tPOST /stamps/:amount/:depth üîó\t‚ùå‚úÖ‚úÖ topUpBatch\tPATCH /stamps/topup/:batchId/:amount üîó\t‚ùå‚úÖ‚úÖ diluteBatch\tPATCH /stamps/dilute/:batchId/:depth üîó\t‚ùå‚úÖ‚úÖ createEnvelope\tPOST /envelope/:reference üîó\t‚ùå‚úÖ‚úÖ getStake\tGET /stake üîó\t‚ùå‚ùå‚úÖ depositStake\tPOST /stake üîó\t‚ùå‚ùå‚úÖ ","version":"Next","tagName":"h3"},{"title":"Utils‚Äã","type":1,"pageTitle":"SDK Overview","url":"/docs/overview/#utils","content":"General‚Äã getCollectionSizegetFolderSize PSS‚Äã makeMaxTarget Erasure Coding‚Äã approximateOverheadForRedundancyLevelgetRedundancyStatgetRedundancyStats Stamps‚Äã getStampCostgetStampEffectiveBytesgetStampUsage ","version":"Next","tagName":"h3"},{"title":"Staking","type":0,"sectionRef":"#","url":"/docs/staking/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"Staking","url":"/docs/staking/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Get staked xBZZStake xBZZGet redistribution state ","version":"Next","tagName":"h2"},{"title":"Postal Service over Swarm","type":0,"sectionRef":"#","url":"/docs/pss/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Remove the unrelated intro sectionShow a listenerShow a one time receiveShow a send invocationMove it towards the end of the chapters, it is not very important Swarm provides the ability to send messages that appear to be normal Swarm traffic, but are in fact messages that may be received and decrypted to reveal their content only to specific nodes that were intended to receive them. PSS provides a pub-sub facility that can be used for a variety of tasks. Nodes are able to listen to messages received for a specific topic in their nearest neighbourhood and create messages destined for another neighbourhood which are sent over the network using Swarm's usual data dissemination protocols. The intended use of PSS is to communicate privately with a publicly known identity (to for example initiate further communication directly). Due to the cost of mining the trojan chunks, it is not recommended to use as an instant messaging system. Light nodes are unreachable Be aware! You can not send message to Light nodes! This is because light nodes does not fully participate in the data exchange in Swarm network and hence the message won't arrive to them. ","version":"Next","tagName":"h2"},{"title":"Getting the relevant data‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#getting-the-relevant-data","content":"When you start bee, you may find all the necessary information in the log: INFO using existing swarm network address: 9e2ebf266369090091620db013aab164afb1574aedb3fcc08ce8dc6e6f28ef54 INFO swarm public key 03e0cee7e979fa99350fc2e2f8c81d857b525b710380f238742af269bb794dfd3c INFO pss public key 02fa24cac43531176d21678900b37bd800c93da3b02c5e11572fb6a96ec49527fa INFO using ethereum address 5f5505033e3b985b88e20616d95201596b463c9a  Let's break it down: Ethereum address is the public address of your node wallet. Together with the corresponding private key, it is used for things such as making Ethereum transactions (receiving and sending ETH and BZZ); receiving, claiming and singing cheques and the Swarm network address is also derived from it.The Swarm network address defines your location in the kademlia and within the context of PSS is used for addressing the trojan chunks to you. In other words, others may use it to send you a message.PSS public key can be used by others to encrypt their messages for you. ","version":"Next","tagName":"h2"},{"title":"Sending message‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#sending-message","content":"To send data simply define a topic, prefix of the recipient's swarm network address (we recommend 4-6 character prefix length) and the data to be send. Your communication privacy may be at risk When sending PSS messages without encryption key, any Bee node through which the trojan chunk passes would be able to read the message. TypeScriptJavaScript /** * @param {string} topic * @param {string} targetPrefix * @param {string|Uint8Array} data * @param {string} encryptionKey */ bee.pssSend('topic', '9e2e', 'Hello!')  If you want to encrypt the message, you may provide the recipient's PSS public key. TypeScriptJavaScript bee.pssSend( 'topic', '9e2e', 'Encrypted Hello!', '02fa24cac43531176d21678900b37bd800c93da3b02c5e11572fb6a96ec49527fa', )  ","version":"Next","tagName":"h2"},{"title":"Retrieving message‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#retrieving-message","content":"As a recipient, you have two ways how to receive the message. If you are expecting one off message (which is the intended PSS use case to exchange credentials for further direct communication), you can use the pssReceive method. TypeScriptJavaScript const message = await bee.pssReceive('topic') console.log(message.text()) // prints the received message  If you want to subscribe to multiple messagees, use the pssSubscribe method. TypeScriptJavaScript const handler = { onMessage: (message: Data) =&gt; {console.log(message.text())}, onError: (error: BeeError) =&gt; {console.log(error)} } // Subscribe const subscription = bee.pssSubscribe('topic', handler) // Terminate the subscription subscription.cancel()  ","version":"Next","tagName":"h2"},{"title":"SOC and Feeds","type":0,"sectionRef":"#","url":"/docs/soc-and-feeds/","content":"","keywords":"","version":"Next"},{"title":"üöß Under Construction üöß‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#-under-construction-","content":"üöß This page is under construction This section is still being worked on. Check back soon for updates! Swarm provides the ability to store content in content-addressed chunks or Single Owner Chunks (SOC). With single owner chunks, a user can assign arbitrary data to an address and attest chunk integrity with their digital signature. Feeds are a unique feature of Swarm. They constitute the primary use case for single owner chunks. Developers can use Feeds to version revisions of a mutable resource, indexing sequential updates to a topic, publish the parts to streams, or post consecutive messages in a communication channel. Feeds implement persisted pull-messaging and can also be interpreted as a pub-sub system. Because Feeds are built on top of SOCs, their interfaces are somewhat similar and use common concepts. ","version":"Next","tagName":"h2"},{"title":"Single Owner Chunks‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#single-owner-chunks","content":"Bee-js calculates a SOC address as the hash of an identifier and owner. The identifier is a 32 bytes long arbitrary data, usually expected as a hex string or a Uint8Array. The owner is an Ethereum address that consists of 20 bytes in a format of a hex string or Uint8Array. SOCs are immutable! You might be tempted to modify a SOC's content to &quot;update&quot; the chunk. Reuploading of SOC is forbidden in Swarm as it might create uncertain behavior. Bee node will reject the API call if it finds already existing SOC for the given address. Either use a different identifier, or you might be looking for Feeds as your use case. ","version":"Next","tagName":"h2"},{"title":"Reading SOCs‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#reading-socs","content":"To read data from a SOC, we need to make a reader object bound to a specific owner. Then we can download the data with the provided chunk's identifier. const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const socReader = bee.makeSOCReader(owner) const identifier = '0000000000000000000000000000000000000000000000000000000000000000' const soc = await socReader.download(identifier) const data = soc.payload()  ","version":"Next","tagName":"h3"},{"title":"Writing SOCs‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#writing-socs","content":"When writing a SOC, first, we need to make a writer object. Because we need to sign the chunk, we need to pass in a signer object. The signer object can be either an Ethereum private key (as a hex string or Uint8Array) or an instance of the Signer interface. The Signer interface can be used for integration with 3rd party Ethereum wallet applications because Swarm uses the same format for signing chunks that Ethereum uses for signing transactions. Default signer When you are instantiating Bee class you can pass it a default signer that will be used if you won't specify it directly for the makeSOCWriter. See Bee constructor for more info. Ethereum Wallet signers If you want to use your browser Ethereum Wallet like Metamask you can use utility called makeEthereumWalletSigner that we ship with bee-js which creates a Signer object out of given EIP-1193 compatible provider. See it used in our example here. import { Utils } from '@ethersphere/bee-js' const signer = Utils.makeEthereumWalletSigner(window.ethereum) ...  type SyncSigner = (digest: Data) =&gt; Signature | string type AsyncSigner = (digest: Data) =&gt; Promise&lt;Signature | string&gt; /** * Interface for implementing Ethereum compatible signing. * * @property sign The sign function that can be sync or async * @property address The Ethereum address of the signer */ export type Signer = { sign: SyncSigner | AsyncSigner address: EthAddress }  Your communication privacy may be at risk We suggest using either ephemeral private keys (e.g. randomly generated) or the Signer interface when writing to SOC or Feeds. Never use your real Ethereum private keys here (or in any web applications really) directly because you may lose your funds stored on it. Using the writer interface is similar to using the reader: const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' const socWriter = bee.makeSOCWriter(signer) const identifier = '0000000000000000000000000000000000000000000000000000000000000000' const data = new Uint8Array([1, 2, 3]) const response = await socWriter.upload(postageBatchId, identifier, data)  ","version":"Next","tagName":"h3"},{"title":"Feeds‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#feeds","content":"Feeds are an abstraction built on top of SOCs to provide mutable resources on the otherwise immutable data types that Swarm supports. One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated. A feed is defined by its owner (see above), a topic (32 bytes arbitrary data as a hex string or Uint8Array), and a type. type defines how the updates and lookup of the feed index are made (currently only the sequence type is supported). The publisher is the owner of the feed, and only they can post updates to the feed. Posting an update requires (1) constructing the identifier from the topic and the correct index and (2) signing it concatenated together with the hash of the arbitrary content of the update. Conversely, users can consume a feed by retrieving the chunk by its address. Retrieving an update requires the consumer to construct the address from the owner‚Äôs address and the identifier. To calculate the identifier, they need the topic and the appropriate index. For this, they need to know the indexing scheme. Feeds enable Swarm users to represent a sequence of content updates. The content of the update is the payload that the feed owner signs against the identifier. The payload can be a swarm reference from which the user can retrieve the associated data. ","version":"Next","tagName":"h2"},{"title":"Topic‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#topic","content":"In Swarm, topic is a 32-byte long arbitrary byte array. It's possible to choose an arbitrary topic for each application, and then knowing someone's (or something's) address, it's possible to find their feeds. Also, this can be the hash of a human-readable string, specifying the topic and optionally the subtopic of the feed. There is a helper function provided for that: const topic = bee.makeFeedTopic('my-dapp.eth/outbox')  ","version":"Next","tagName":"h3"},{"title":"High level JSON API‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#high-level-json-api","content":"Many applications are storing or manipulating data in JSON. bee-js has convenience high level API to use feeds with JSON objects. It consists of two methods: setJsonFeed method to set JSON compatible data to feedgetJsonFeed method to get JSON compatible data (and parse them) from feed Bee's instance signer You can pass a Signer (or compatible data) into Bee class constructor, which then will be used as default Signer. const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) await bee.setJsonFeed( postageBatchId, 'some cool arbitraty topic', { some: ['cool', { json: 'compatible' }, 'object']}, { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' } ) const data = await bee.getJsonFeed( 'some cool arbitraty topic', { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' } ) console.log(data) // Prints: { some: ['cool', { json: 'compatible' }, 'object']}  ","version":"Next","tagName":"h3"},{"title":"Low level API‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#low-level-api","content":"Low level API is an API that is more flexible in its usage, but requires better understanding and mainly more method calls. Reading feeds‚Äã To read data from a feed, we need to make a reader object for a specific type, topic and owner, then we can download the latest update containing a reference. const topic = '0000000000000000000000000000000000000000000000000000000000000000' const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const feedReader = bee.makeFeedReader('sequence', topic, owner) const feedUpdate = await feedReader.download() console.log(feedUpdate.reference) // prints the latest reference stored in the feed  Writing feeds‚Äã When writing a feed, typically an immutable content is uploaded first, and then its reference is updated in the feed. The signer here is the same as with writing the SOCs (with the same caveats!). const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const data = new Uint8Array([1, 2, 3]) const reference = await bee.uploadData(data) const topic = '0000000000000000000000000000000000000000000000000000000000000000' const signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' const feedWriter = bee.makeFeedWriter('sequence', topic, signer) const response = await feedWriter.upload(postageBatchId, reference)  ","version":"Next","tagName":"h3"},{"title":"Using feed manifest‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#using-feed-manifest","content":"One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated. Swarm provides a feature called &quot;feed manifests&quot; for this use case. It is a content-addressed chunk that stores a feed's definition (the type, the topic, and the owner). When it is looked up using the bzz endpoint, Swarm recognizes that it refers to a feed and continues the lookup according to the feed parameters. const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const topic = '0000000000000000000000000000000000000000000000000000000000000000' const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const reference = bee.createFeedManifest(postageBatchId, 'sequence', topic, owner)  This creates the feed manifest chunk on Swarm. You can use the returned reference to look up with the /bzz endpoint or use it with ENS. ","version":"Next","tagName":"h3"},{"title":"Upload and Download","type":0,"sectionRef":"#","url":"/docs/upload-download/","content":"","keywords":"","version":"Next"},{"title":"Requirements‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#requirements","content":"To use the example scripts below, you need: An instance of bee-js's Bee initialized as bee using the API endpoint of a currently operating Bee node.(Uploads only) The batch ID of a previously purchased usable postage batch with enough remainingSize left to upload the desired data. If you don't have one already, you will need to buy a batch to upload data. If you do have one, you will need to get and save its batch ID. ","version":"Next","tagName":"h2"},{"title":"Uploading‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#uploading","content":"The examples below assume you already have an instance of the Bee class initialized as bee, and the batch ID of a valid postage stamp batch saved as a string in postageBatchId. ","version":"Next","tagName":"h2"},{"title":"Upload Data‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#upload-data","content":"You can upload and retrieve any string or Uint8Array data with the uploadData and downloadData functions. When you download data the return type is the Data interface which extends Uint8Array with convenience functions like: text() that converts the bytes into UTF-8 encoded stringhex() that converts the bytes into non-prefixed hex stringjson() that converts the bytes into JSON object const result = await bee.uploadData(postageBatchId, &quot;Bee is awesome!&quot;) // prints Swarm hash of the file with which it can be retrieved // here it is fd79d5e0ebd8407e422f53ce1d7c4c41ebf403be55143900f8d1490560294780 console.log(result.reference) const retrievedData = await bee.downloadData(result.reference) console.log(retrievedData.text()) // prints 'Bee is awesome!'  Tip A Swarm reference or hash is a 64 character long hex string which is the address of the uploaded data, file, or directory. It must saved so it can be used later to retrieve the uploaded content. ","version":"Next","tagName":"h3"},{"title":"Upload Single file‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#upload-single-file","content":"You can also upload files by specifying a filename. When you download the file, bee-js will return additional information like the contentType or name of the file. const result = await bee.uploadFile(postageBatchId, &quot;Bee is awesome!&quot;, &quot;textfile.txt&quot;) const retrievedFile = await bee.downloadFile(result.reference) console.log(retrievedFile.name) // prints 'textfile.txt' console.log(retrievedFile.contentType) // prints 'application/octet-stream' console.log(retrievedFile.data.text()) // prints 'Bee is awesome!'  In browsers, you can directly upload using the File interface. The filename is taken from the File object itself, but can be overwritten through the second argument of the uploadFile function. const file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; }) const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFile(postageBatchId, file) const retrievedFile = await bee.downloadFile(result.reference) console.log(retrievedFile.name) // prints 'foo.txt' console.log(retrievedFile.contentType) // prints 'text/plain' console.log(retrievedFile.data.text()) // prints 'foo'  ","version":"Next","tagName":"h3"},{"title":"Files and Directories‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#files-and-directories","content":"In browsers, you can easily upload an array of File objects coming from your form directly with FileList. If the files uploaded through uploadFiles have a relative path, they are added relative to this filepath. Otherwise, the whole structure is flattened into single directory. const foo = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; }) const bar = new File([&quot;bar&quot;], &quot;bar.txt&quot;, { type: &quot;text/plain&quot; }) const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFiles(postageBatchId, [ foo, bar ]) // upload const rFoo = await bee.downloadFile(result.reference, './foo.txt') // download foo const rBar = await bee.downloadFile(result.reference, './bar.txt') // download bar console.log(rFoo.data.text()) // prints 'foo' console.log(rBar.data.text()) // prints 'bar'  In NodeJS, you may utilize the uploadFilesFromDirectory function, which takes the directory path as input and uploads all files in that directory. Let's assume we have the following file structure: . +-- foo.txt +-- dir | +-- bar.txt  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFilesFromDirectory(postageBatchId, './') // upload recursively current folder const rFoo = await bee.downloadFile(result.reference, './foo.txt') // download foo const rBar = await bee.downloadFile(result.reference, './dir/bar.txt') // download bar console.log(rFoo.data.text()) // prints 'foo' console.log(rBar.data.text()) // prints 'bar'  ","version":"Next","tagName":"h3"},{"title":"Checking Node Status","type":0,"sectionRef":"#","url":"/docs/status/","content":"","keywords":"","version":"Next"},{"title":"Requirements‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#requirements","content":"To use the example scripts below, you need: An instance of the Bee class from bee-js initialized using the API endpoint of a currently operating Bee node.  ","version":"Next","tagName":"h3"},{"title":"1. Node Health and Readiness‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#1-node-health-and-readiness","content":"Use this to access the health and readiness endpoint return values used for container orchestration tools like Kubernetes. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function checkHealthAndReadiness() { const health = await bee.getHealth() const readiness = await bee.getReadiness() console.log('Health:', health) console.log('Readiness:', readiness) } checkHealthAndReadiness()  Output: Health: { apiVersion: '7.3.0', version: '2.5.0-5ec231ba', status: 'ok' } Readiness: { apiVersion: '7.3.0', version: '2.5.0-5ec231ba', status: 'ready' }  ","version":"Next","tagName":"h3"},{"title":"2. Get Node Topology‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#2-get-node-topology","content":"Use this to inspect how many peers you're connected to, and the state of your neighborhood. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function checkTopology() { const topology = await bee.getTopology() console.log('Topology:', topology) } checkTopology()  Output: (Bins 1 - 30 omitted from bins result) Topology: { baseAddr: '1e2054bec3e681aeb0b365a1f9a574a03782176bd3ec0bcf810ebcaf551e4070', population: 5619, connected: 135, timestamp: '2025-03-26T07:54:05.921263981Z', nnLowWatermark: 3, depth: 10, reachability: 'Public', networkAvailability: 'Available', bins: { bin_0: { population: 2714, connected: 16, connectedPeers: [Array], disconnectedPeers: [Array] }, ... bin_31: { population: 0, connected: 0, connectedPeers: [], disconnectedPeers: [] } } }  ","version":"Next","tagName":"h3"},{"title":"3. Get Node Addresses‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#3-get-node-addresses","content":"This will give you the overlay address, underlay addresses, and Ethereum address associated with your Bee node (the address is an Ethereum style address however it is for a Gnosis Chain account, not mainnet Ethereum). import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function checkAddresses() { const addresses = await bee.getNodeAddresses() console.log('Node Addresses:', addresses) } checkAddresses()  Output: Node Addresses: Overlay: 1e2054bec3e681aeb0b365a1f9a574a03782176bd3ec0bcf810ebcaf551e4070 Ethereum: 9a73f283cd9211b96b5ec63f7a81a0ddc847cd93 Public Key: 7d0c4759f689ea3dd3eb79222870671c492cb99f3fade275bcbf0ea39cd0ef6e25edd43c99985983e49aa528f3f2b6711085354a31acb4e7b03559b02ec868f0 PSS Public Key: 5ade58d20be7e04ee8f875eabeebf9c53375a8fc73917683155c7c0b572f47ef790daa3328f48482663954d12f6e4739f748572c1e86bfa89af99f17e7dd4d33 Underlay: [ '/ip4/127.0.0.1/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j', '/ip4/172.17.0.2/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j', '/ip6/::1/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j' ]  ","version":"Next","tagName":"h3"},{"title":"4. Get Version and API Compatibility‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#4-get-version-and-api-compatibility","content":"Use these methods to check your node's version number and the API version number, and to check whether the API version is supported by bee-js. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function checkVersions() { const versions = await bee.getVersions() const isSupported = await bee.isSupportedApiVersion() console.log('Node Versions:', versions) console.log('Is Supported API Version:', isSupported) } checkVersions()  Output: Node Versions: { supportedBeeVersion: '2.4.0-390a402e', supportedBeeApiVersion: '7.2.0', beeVersion: '2.5.0-5ec231ba', beeApiVersion: '7.3.0' } Is Supported API Version: true  ","version":"Next","tagName":"h3"},{"title":"5. Get Node Info‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#5-get-node-info","content":"This provides general information such as node mode (e.g., full, light), and whether chequebook and SWAP are enabled. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function getNodeInfo() { const info = await bee.getNodeInfo() console.log('Node Info:', info) } getNodeInfo()  Output: Node Info: { beeMode: 'light', chequebookEnabled: true, swapEnabled: true }  ","version":"Next","tagName":"h3"},{"title":"6. Get Chain State‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#6-get-chain-state","content":"Shows blockchain-related info such as the current price for storage. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function getChainState() { const state = await bee.getChainState() console.log('Chain State:', state) } getChainState()  Output: Chain State: { block: 39230575, chainTip: 39230580, totalAmount: '204168626286', currentPrice: 41699 }  ","version":"Next","tagName":"h3"},{"title":"7. Get Reserve State‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#7-get-reserve-state","content":"This tells you about your node‚Äôs local reserve size and storage metrics. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function getReserveState() { const reserveState = await bee.getReserveState() console.log('Reserve State:', reserveState) } getReserveState()  Output: Reserve State: { commitment: 17360879616, radius: 13, storageRadius: 0 }  ","version":"Next","tagName":"h3"},{"title":"Run All Checks Together‚Äã","type":1,"pageTitle":"Checking Node Status","url":"/docs/status/#run-all-checks-together","content":"You can combine all of the above into one function to quickly inspect the full status of your node: import { Bee, Bytes } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') async function checkHealthAndReadiness() { const health = await bee.getHealth() const readiness = await bee.getReadiness() console.log('Health:', health) console.log('Readiness:', readiness) } async function checkTopology() { const topology = await bee.getTopology() console.log('Topology:', topology) } async function checkAddresses() { const addresses = await bee.getNodeAddresses() console.log('Node Addresses:') console.log('Overlay:', new Bytes(addresses.overlay.bytes).toHex()) console.log('Ethereum:', new Bytes(addresses.ethereum.bytes).toHex()) console.log('Public Key:', new Bytes(addresses.publicKey.bytes).toHex()) console.log('PSS Public Key:', new Bytes(addresses.pssPublicKey.bytes).toHex()) console.log('Underlay:', addresses.underlay) } async function checkVersions() { const versions = await bee.getVersions() const isSupported = await bee.isSupportedApiVersion() console.log('Node Versions:', versions) console.log('Is Supported API Version:', isSupported) } async function getNodeInfo() { const info = await bee.getNodeInfo() console.log('Node Info:', info) } async function getChainState() { const state = await bee.getChainState() console.log('Chain State:', state) } async function getReserveState() { const reserveState = await bee.getReserveState() console.log('Reserve State:', reserveState) } async function checkNodeStatus() { console.log('\\n\\n=== Node Health and Readiness ===') await checkHealthAndReadiness() console.log('\\n\\n=== Node Topology ===') await checkTopology() console.log('\\n\\n=== Node Addresses ===') await checkAddresses() console.log('\\n\\n=== Version and API Compatibility ===') await checkVersions() console.log('\\n\\n=== Node Info ===') await getNodeInfo() console.log('\\n\\n=== Chain State ===') await getChainState() console.log('\\n\\n=== Reserve State ===') await getReserveState() } checkNodeStatus()  ","version":"Next","tagName":"h3"},{"title":"Buying Storage","type":0,"sectionRef":"#","url":"/docs/storage/","content":"","keywords":"","version":"Next"},{"title":"Requirements‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#requirements","content":"To use the example scripts below, you need: An instance of bee-js's Bee initialized using the API endpoint of a currently operating Bee node  ","version":"Next","tagName":"h3"},{"title":"Checking Storage Costs‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#checking-storage-costs","content":"We can use the bee.getStorageCost method along with our desired storage Size (amount of data to upload) and Duration (the batch lifetime) to get an estimated storage cost: tip The per byte storage cost decreases as the storage Size of the batch increases, so it is more cost effective to purchase a single large batch rather than multiple smaller ones. Costs remain constant with respect to changes in total Duration, however, so there is no discount for purchasing batches with longer lifetime. import { Bee, Size, Duration } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Get cost in BZZ to store 4 GB for ~1 day const bzz = await bee.getStorageCost(Size.fromGigabytes(1), Duration.fromDays(1)) // Prints &quot;0.325&quot; given the storage cost of 44908 PLUR at time of writing console.log(bzz.toSignificantDigits(3))  danger The actual lifetime of the batch may be higher or lower than the specified Duration due to Swarm's dynamic pricing model. The amount that the price can change each day is limited, however, so you don't need to worry about a rapid increase in price causing your batch to unexpectedly expire over the course of a few hours. You can view the current price of storage on Swarmscan. ","version":"Next","tagName":"h3"},{"title":"Purchasing Storage‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#purchasing-storage","content":"The bee.buyStorage method abstracts away some of the lower level details of tip When purchasing storage with bee.buyStorage, a postage batch will be bought with at least enough space to upload the specified amount of data. However since storage on Swarm comes in discrete sizes, the actual amount of space will likely be greater than specified. The bee.buyStorage method takes instances of the Size and Duration utility classes and purchases a postage batch which can upload at least as much data as the given Size and store it for the given Duration (the actual duration of storage may be longer or shorter depending on the change in storage price over time), and then save the postage batch data locally. The transaction usually only takes a few seconds but may take up to a minute. import { Bee, Size, Duration } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Purchase a batch to store 1 GB const batchId = await bee.buyStorage(Size.fromGigabytes(1), Duration.fromDays(1))  Once the purchase transaction is complete, the method will return a unique postage batch id. The lifetime of the batch starts counting down from the moment of purchase. The batch in the example above will expire in about 24 hours. ","version":"Next","tagName":"h3"},{"title":"Extending Storage Size‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#extending-storage-size","content":"tip Just as with buying storage, since storage comes only in discrete sizes, the actual amount of additional space when extending the storage size of an existing batch will typically be greater than specified. If we need to upload more data, then we can extend a batch's storage size using the bee.extendStorageSize method. Note that in order to increase the batch size using the extendStorageSize method, you must choose a size which is above the current batch's size breakpoint. tip As mentioned above, the per byte cost decreases as the storage size of a batch increases, so it's more cost effective to increase the storage size an existing batch rather than buying a new, smaller batch. The exception to this rule is if we no longer wish to store the previously uploaded data. In that case we SHOULD buy an all new postage batch, as extending the size of an existing batch would require us to continue paying for the already uploaded data which we no longer need. First we estimate the cost to extend the storage size with the bee.getSizeExtensionCost method: import { Bee, Size } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() const batchId = batches[0].batchID // Instantiate a Size instance for 36 GB with newSize const newSize = Size.fromGigabytes(5) // Return an instance of the BZZ class const sizeExtentionCost = await bee.getSizeExtensionCost(batchId, newSize) // Use the BZZ.toDecimalString instance method to convert to a readable BZZ string const cost = sizeExtentionCost.toDecimalString() // Prints current cost to increase size console.log(cost)  If the price is acceptable, then we can proceed to extend the batch size using bee.extendStorageSize: import { Bee, Size } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() // Print results to the terminal console.log(batches) // Get batch ID of first batch in list const batchId = batches[0].batchID // Instantiate a Size instance for 36 GB with newSize const newSize = Size.fromGigabytes(5) // Extends batch size and returns the batch ID const result = await bee.extendStorageSize(batchId, newSize) // Log result if successful console.log(result)  We can check that we successfully extended the batch size by checking batch status: [ { batchID: BatchId { bytes: [Uint8Array], length: 32 }, utilization: 0, usable: true, label: '', depth: 23, amount: '1714407552', bucketDepth: 16, blockNumber: 39145214, immutableFlag: true, usage: 0, usageText: '0%', size: Size { bytes: 17028686336 }, remainingSize: Size { bytes: 17028686336 }, theoreticalSize: Size { bytes: 34359738368 }, duration: Duration { seconds: 94453 } } ]  Here we can see that our batch size was successfully extended from ~4.93 GB to ~17.03 GB. See above to understand why size was extended to ~17.03 even though 5 GB was used as input. ","version":"Next","tagName":"h3"},{"title":"Extending Storage Duration‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#extending-storage-duration","content":"If we want our data to remain available on Swarm for a longer period of time, we can extend the duration of a postage batch using the bee.extendStorageDuration method. Extending the duration means adding more BZZ to the batch so that the data stays alive longer on the network. Before extending the duration, we can estimate the cost using the bee.getDurationExtensionCost method: import { Bee, Duration } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() // Select the batch ID of the first batch in the list const batchId = batches[0].batchID // Create a new Duration instance for 0.01 days const additionalDuration = Duration.fromDays(.01) // Estimate the cost of extending the duration const durationExtensionCost = await bee.getDurationExtensionCost(batchId, additionalDuration) // Convert the BZZ value into a readable string const cost = durationExtensionCost.toDecimalString() // Print the estimated cost console.log(cost)  Once we know the cost and decide to proceed, we can use bee.extendStorageDuration to extend the batch duration: import { Bee, Duration } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() // Select the batch ID of the first batch in the list const batchId = batches[0].batchID // Create a Duration instance for 0.1 additional days const additionalDuration = Duration.fromDays(.01) // Extend the duration of the batch const result = await bee.extendStorageDuration(batchId, additionalDuration) // Log the result console.log(result)  We can verify that the extension was successful by checking the batch status. You'll notice the duration value on the batch will have increased, reflecting the newly extended storage time: [ { batchID: BatchId { bytes: [Uint8Array], length: 32 }, utilization: 0, usable: true, label: '', depth: 23, amount: '1722164236', bucketDepth: 16, blockNumber: 39145214, immutableFlag: true, usage: 0, usageText: '0%', size: Size { bytes: 17028686336 }, remainingSize: Size { bytes: 17028686336 }, theoreticalSize: Size { bytes: 34359738368 }, duration: Duration { seconds: 94132 } } ]  Here we can see that the duration value (measured in seconds) has increased, confirming that the batch will now remain alive on the Swarm network for longer. tip If you're storing important or long-lived data, it's a good idea to periodically check and extend the duration of your batches to ensure your data doesn't expire unexpectedly. ","version":"Next","tagName":"h3"},{"title":"Estimating Combined Size and Duration Extension Cost‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#estimating-combined-size-and-duration-extension-cost","content":"If we want to increase both the storage size and duration of a postage batch, we can use the Bee.getExtensionCost method to estimate the total cost of the extension. This is useful when you're planning to keep data alive for longer and want to increase capacity for uploading more data at the same time. The getExtensionCost method combines both aspects ‚Äî size and duration ‚Äî into a single cost calculation, making it easier to understand the overall expense upfront. Here‚Äôs how to use it: import { Bee, Size, Duration } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() // Choose a batch to extend const batchId = batches[0].batchID // Define a new desired size (e.g., 10 GB) const newSize = Size.fromGigabytes(10) // Define a new additional duration (e.g., 14 days) const additionalDuration = Duration.fromDays(14) // Estimate total BZZ cost for extending both size and duration const totalCost = await bee.getExtensionCost(batchId, newSize, additionalDuration) // Convert to a readable string const cost = totalCost.toDecimalString() // Print total estimated cost console.log(cost)  This method helps you determine if it's more economical to extend an existing batch or create a new one, especially when both dimensions‚Äîstorage and time‚Äîneed to grow. tip If you're unsure whether to extend a batch or start fresh, compare the output of getExtensionCost with the cost of a new batch using the Postage Stamp Pricing Guide. In many cases, extending is cheaper, especially for larger and longer-lived batches. If you're happy with the cost, you can then proceed to extend the size and duration individually by calling extendStorageSize and extendStorageDuration as shown in the previous sections. ","version":"Next","tagName":"h3"},{"title":"Checking Batch Status‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#checking-batch-status","content":"You can check the status of purchased batches using the bee.getAllPostageBatch method: import { Bee } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') // Request all local postage batches const batches = await bee.getAllPostageBatch() // Print results to the terminal console.log(batches)  The results printed to the terminal will include all the currently valid postage batches we've purchased: [ { batchID: BatchId { bytes: [Uint8Array], length: 32 }, utilization: 0, usable: true, label: '', depth: 22, amount: '931958784', bucketDepth: 16, blockNumber: 39105960, immutableFlag: true, usage: 0, usageText: '0%', size: Size { bytes: 4925468496 }, remainingSize: Size { bytes: 4925468496 }, theoreticalSize: Size { bytes: 17179869184 }, duration: Duration { seconds: 84348 } } ]  We can disregard many of these values since they are only needed for advanced usage. There are several values we do need to pay attention to however: usable - it takes a short time for a batch to become usable (usually less than a minute) after purchase. Once usable, usable will change from false to true.usage - indicates how much of the batch has been used as a value between 1 and 0.usageText - converts the usage value to a percentage value rounded to the nearest whole number which is then converted to text.size - the amount of data in bytes which the batch can safely store.remainingSize - the amount of date in bytes remaining from size which is still available to be used.duration - an estimate of the remaining batch lifetime in seconds. For an explanation of the remaining values, refer to the &quot;Advanced&quot; section below. tip Note that although 1 GB was specified as input for the bee.buyStorage, the size value is ~4.93 GB. Refer to the section about batch sizes above to understand why. ","version":"Next","tagName":"h3"},{"title":"Selecting a Batch‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#selecting-a-batch","content":"Any method in bee-js which writes data to Swarm requires the batch id of a valid, usable postage batch with remaining space to upload data. The example script below exports a function which looks for the first usable postage batch with remaining space and returns the id of the batch. notice This function is used throughout the examples here in the docs. import { Bee } from '@ethersphere/bee-js' const bee = new Bee('http://localhost:1633') export async function getBatch(bee, criteriaFn) { const batches = await bee.getAllPostageBatch() const matchingBatch = batches.find(criteriaFn) if (!matchingBatch) { throw new Error('No postage batch matched the provided criteria.') } return matchingBatch.batchID.toString() }  To use it, save the script to a file called getBatch.js so we can import the it in our other scripts. import { Bee } from '@ethersphere/bee-js' import { getBatch } from './getBatch' const bee = new Bee('http://localhost:1633') // Define the selection criteria as a named function function isUsableWithFreeSpace(batch) { return batch.usable &amp;&amp; batch.remainingSize?.bytes &gt; 0 } const batchId = getBatch(bee, isUsableWithFreeSpace)  If you need a batch with specific characteristics (such as a batch with at least 10 GB remaining space or a mutable batch), then you should inspect your postage batches' status using bee.getAllPostageBatch in order to check if a batch with your desired characteristics exists and return its id. ","version":"Next","tagName":"h3"},{"title":"Batch Size Breakpoints‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#batch-size-breakpoints","content":"Batches are bought in discrete size intervals as shown in the table below. As the effective volume increases, so does the discount percentage, which eventually converges to around 68% with larger volumes. Costs are recorded at time of writing and are subject to change. Use the bee.getStorageCost method for current price. Breakpoint\tEffective Volume\txBZZ / day / GB Cost\t% Discount1\t4.93 GB\t0.066\t0% 2\t17.03 GB\t0.038\t42% 3\t44.21 GB\t0.030\t55% 4\t102.78 GB\t0.025\t62% 5\t225.86 GB\t0.023\t65% 6\t480.43 GB\t0.022\t67% 7\t1.00 TB\t0.021\t68% 8\t2.06 TB\t0.021\t68% When purchasing a batch / estimating batch price, bee-js will round up to the nearest effective volume. For example, if the bee.buyStorage method is used to buy a batch with 1 GB as input, bee-js will round up to the first breakpoint and buy a batch with 4.93 GB effective volume. If 5 GB is used as input, then bee-js will round up to the second breakpoint of 17.03 GB since 5 GB is larger than the first breakpoint of 4.93 GB. Refer to the Bee documentation for a more in-depth understanding of batch utilization. ","version":"Next","tagName":"h3"},{"title":"Utility Classes‚Äã","type":1,"pageTitle":"Buying Storage","url":"/docs/storage/#utility-classes","content":"Size‚Äã The Size class represents a storage size in bytes, with helper methods for creating and converting values. Creating a Size instance‚Äã The class includes two static methods for creating an instance of the Size class from either raw bytes or from gigabytes: Size.fromBytesSize.fromGigabytes import { Size } from '@ethersphere/bee-js' // Create a Size instance from raw bytes const sizeA = Size.fromBytes(5000000000) // Or from gigabytes const sizeB = Size.fromGigabytes(5) // ‚Üí 5 GB = 5,000,000,000 bytes  Converting and formatting‚Äã The class also includes three instance methods for getting the value from an existing Size instance as either raw bytes, gigabytes, or formatted text: size.toBytessize.toGigabytessize.toFormattedString // Using `sizeB` from the previous example sizeB.toBytes() // ‚Üí 5000000000 sizeB.toGigabytes() // ‚Üí 5 sizeB.toFormattedString() // ‚Üí '5.00 GB'  Duration‚Äã The Duration class represents a length of time in seconds, with helper methods for creating and converting durations in various common time units. tip All of the helper methods for Duration take numbers as input except for toEndDate fromEndDate which both take a Date object as input. Creating a Duration instance‚Äã The class includes several static methods for creating a Duration instance from values like milliseconds, seconds, days, or even from dates: Duration.fromMillisecondsDuration.fromSecondsDuration.fromHoursDuration.fromDaysDuration.fromWeeksDuration.fromYearsDuration.fromEndDate import { Duration } from '@ethersphere/bee-js' // Create a duration of 3 days const durationA = Duration.fromDays(3) // Create a duration from now until a future date const endDate = new Date('2025-04-01T12:00:00Z') const durationB = Duration.fromEndDate(endDate)  Converting and formatting‚Äã The class also includes several instance methods for converting a Duration instance into different time units or for getting a future date from a starting point: duration.toSecondsduration.toHoursduration.toDaysduration.toWeeksduration.toYearsduration.toEndDate // Using `durationA` from the previous example durationA.toSeconds() // ‚Üí 259200 durationA.toDays() // ‚Üí 3 durationA.toEndDate() // ‚Üí Date object 3 days from now // You can also specify a custom starting date const startDate = new Date('2025-01-01T00:00:00Z') durationA.toEndDate(startDate) // ‚Üí Date object 3 days after Jan 1  This class is useful when: Setting how long data should remain available in SwarmEstimating or displaying expiration time for postage batchesWorking with bee.buyStorage, bee.getStorageCost, or bee.extendStorageDuration ","version":"Next","tagName":"h3"},{"title":"Utility Classes","type":0,"sectionRef":"#","url":"/docs/utilities/","content":"","keywords":"","version":"Next"},{"title":"Bytes - Data Conversions & Manipulation‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#bytes---data-conversions--manipulation","content":"The Bytes class in bee-js provides a convenient wrapper for manipulating byte arrays, converting between encodings, slicing, hashing, and more. It‚Äôs used throughout bee-js as the basis for other utility classes like Signature, Reference, PrivateKey, and more, all of which extend the Bytes class. It is also a core data type used throughout the SDK as expected input/returned data type for various methods. // Import Bytes class import { Bytes } from '@ethersphere/bee-js'  ","version":"Next","tagName":"h2"},{"title":"Hashing with keccak256‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#hashing-with-keccak256","content":"Methods: Bytes.fromUtf8(): Converts a UTF-8 string to a Bytes instance.Bytes.keccak256(): Computes the keccak256 hash of the given byte input.toHex(): Converts the byte data to a hexadecimal string. // --- Hashing with keccak256 --- console.log('--- keccak256 Hashing ---') console.log('Empty string hash:', Bytes.keccak256(Bytes.fromUtf8('')).toHex()) console.log('Hello, world! hash:', Bytes.keccak256(Bytes.fromUtf8('Hello, world!')).toHex())  --- keccak256 Hashing --- Empty string hash: c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 Hello, world! hash: b6e16d27ac5ab427a7f68900ac5559ce272dc6c37c82b3e052246c82244c50e4  ","version":"Next","tagName":"h3"},{"title":"Creating Bytes Instances‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#creating-bytes-instances","content":"Methods: Bytes.fromUtf8(): Creates a Bytes instance from a UTF-8 string.Bytes.fromSlice(): Creates a Bytes instance from a slice of a Uint8Array.new Bytes(...): Constructs a new Bytes instance from various inputs like strings, ArrayBuffer, or Uint8Array.toHex(): Converts the byte data to a hexadecimal string. // --- Creating Bytes instances --- console.log('\\n--- Creating Bytes Instances ---') const bytesFromString = Bytes.fromUtf8('Swarm') console.log('From UTF-8 string:', bytesFromString.toHex()) const source = new Uint8Array([1, 2, 3, 4, 5]) const slice = Bytes.fromSlice(source, 1, 3) console.log('From slice of Uint8Array:', slice.toHex()) const fromHex = new Bytes('0xdeadbeef') console.log('From hex string:', fromHex.toHex()) const cloned = new Bytes(fromHex) console.log('Cloned Bytes instance:', cloned.toHex()) const fromArray = new Bytes(new Uint8Array([16, 32, 48])) console.log('From raw Uint8Array:', fromArray.toHex())  --- Creating Bytes Instances --- From UTF-8 string: 537761726d From slice of Uint8Array: 020304 From hex string: deadbeef Cloned Bytes instance: deadbeef From raw Uint8Array: 102030  ","version":"Next","tagName":"h3"},{"title":"Accessing and Converting Bytes‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#accessing-and-converting-bytes","content":"Methods: toUint8Array(): Converts the Bytes instance to a Uint8Array.toHex(): Converts the byte data to a hexadecimal string.toBase64(): Converts the byte data to a Base64-encoded string.toBase32(): Converts the byte data to a Base32-encoded string.toUtf8(): Converts the byte data to a UTF-8 string.toString(): Converts the byte data to a hexadecimal string (alias for toHex()).toJSON(): Parses the byte data (assumed to be a JSON string) and returns the corresponding JavaScript object. // --- Accessing and Converting Bytes --- console.log('\\n--- Accessing and Converting Bytes ---') const data = Bytes.fromUtf8('hello') console.log('toUint8Array():', data.toUint8Array()) console.log('toHex():', data.toHex()) console.log('toBase64():', data.toBase64()) console.log('toBase32():', data.toBase32()) console.log('toUtf8():', data.toUtf8()) console.log('toString():', data.toString()) const json = Bytes.fromUtf8('{&quot;a&quot;: 1, &quot;b&quot;: true}') console.log('toJSON():', json.toJSON())  --- Accessing and Converting Bytes --- toUint8Array(): Uint8Array(5) [ 104, 101, 108, 108, 111 ] toHex(): 68656c6c6f toBase64(): aGVsbG8= toBase32(): NBSWY3DP toUtf8(): hello toString(): 68656c6c6f toJSON(): { a: 1, b: true }  ","version":"Next","tagName":"h3"},{"title":"PrivateKey - Key Management & Signing‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#privatekey---key-management--signing","content":"The PrivateKey class extends the Bytes class. It is initialized with an Ethereum-style private key, which can then be used for signing arbitrary messages. It also has methods for returning the derived Ethereum address and public key. import { PrivateKey } from '@ethersphere/bee-js' // This example shows interoperability of crypto types // Initialize PrivateKey with 32-byte hexadecimal private key const signer = new PrivateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef') console.log('PrivateKey initialized:', signer.toHex()) // Message to be signed const message = 'Hello world!' console.log('Message to sign:', message) // Message signing const signature = signer.sign(message) // type Signature console.log('Generated signature:', signature.toHex()) // Public key derivation const recovered = signature.recoverPublicKey(message) // type PublicKey console.log('Recovered public key:', recovered.toHex()) // Ethereum account address derivation const address = recovered.address() // type EthAddress console.log('Recovered Ethereum address:', address.toHex())  PrivateKey initialized: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef Message to sign: Hello world! Generated signature: 0f0b277880c01e1ed39ad3fadcbd1d317c89ed4ecc9048072a18b370eff3162f5519fa0fa307ed66bac9645bf6e1e5350b3e91a99bcf7104ecfcb6d8443b81301c Recovered public key: 4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559 Recovered Ethereum address: fcad0b19bb29d4674531d6f115237e16afce377c  ","version":"Next","tagName":"h2"},{"title":"BZZ and DAI - Token Conversions & Formatting‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#bzz-and-dai---token-conversions--formatting","content":"import { BZZ, DAI } from '@ethersphere/bee-js'  Initializing and formatting BZZ and DAI tokens. // --- BZZ Initialization --- console.log('--- BZZ Initialization ---') const bzz = BZZ.fromDecimalString('13.37') console.log('BZZ in PLUR String:', bzz.toPLURString()) console.log('BZZ as PLUR BigInt:', bzz.toPLURBigInt()) console.log('BZZ in Decimal String:', bzz.toDecimalString())  --- BZZ Initialization --- BZZ in PLUR String: 133700000000000000 BZZ as PLUR BigInt: 133700000000000000n BZZ in Decimal String: 13.3700000000000000  DAI token initialization, converting from Wei to Decimal string and back. // --- DAI Initialization --- console.log('--- DAI Initialization ---') const daiFromWei = DAI.fromWei('4596417133719887384') console.log('DAI from Wei to Decimal String:', daiFromWei.toDecimalString()) console.log('DAI from Decimal String to Wei BigInt:', DAI.fromDecimalString('4.596417133719887384').toWeiBigInt()) console.log('DAI from Decimal String to Wei String:', DAI.fromDecimalString('4.596417133719887384').toWeiString())  --- DAI Initialization --- DAI from Wei to Decimal String: 4.596417133719887384 DAI from Decimal String to Wei BigInt: 4596417133719887384n DAI from Decimal String to Wei String: 4596417133719887384  Performing arithmetic on BZZ tokens by sending and receiving amounts. // --- BZZ Arithmetic --- console.log('--- BZZ Arithmetic ---') const sent = BZZ.fromDecimalString('1.89') const received = BZZ.fromDecimalString('45.600000061124') console.log('BZZ after arithmetic (sent + received):', sent.plus('401100000000000000').minus(received).toDecimalString())  --- BZZ Arithmetic --- BZZ after arithmetic (sent + received): -3.6000000611240000  Converting BZZ tokens to DAI tokens using a specified exchange rate. // --- Convert BZZ to DAI --- console.log('--- Convert BZZ to DAI ---') const exchangeRate = DAI.fromDecimalString('0.3659') const bzzForExchange = BZZ.fromDecimalString('1000') console.log('BZZ exchanged to DAI at rate 0.3659:', bzzForExchange.exchangeToDAI(exchangeRate).toDecimalString())  --- Convert BZZ to DAI --- BZZ exchanged to DAI at rate 0.3659: 365.900000000000000000  Converting DAI tokens to BZZ tokens using the same exchange rate. // --- Convert DAI to BZZ --- console.log('--- Convert DAI to BZZ ---') const dai = DAI.fromDecimalString('2.591923154542010243') console.log('DAI exchanged to BZZ at rate 0.3659:', dai.exchangeToBZZ(exchangeRate).toDecimalString())  --- Convert DAI to BZZ --- DAI exchanged to BZZ at rate 0.3659: 7.0836926880076803  ","version":"Next","tagName":"h2"},{"title":"Reference - Reference Hashes and CIDs‚Äã","type":1,"pageTitle":"Utility Classes","url":"/docs/utilities/#reference---reference-hashes-and-cids","content":"The Reference class is used to represent content reference hashes and CIDs, and conversions between them. import { Reference } from '@ethersphere/bee-js' const hash = '44ef8a919a7a2a6fe36712d4512047db406cc7ac5c06da7731e0cb87bab10ff9' const cid = 'bah5acgzaitxyvem2pivg7y3hclkfcich3nagzr5mlqdnu5zr4dfypovrb74q' // Convert CID to hash (Hex) console.log('CID to Hash (Hex):', new Reference(cid).toHex()) // Convert Hash (Hex) to CID (Accepts 'manifest' or 'feed' types) console.log('Hash to CID (manifest type):', new Reference(hash).toCid('manifest'))  CID to Hash (Hex): 44ef8a919a7a2a6fe36712d4512047db406cc7ac5c06da7731e0cb87bab10ff9 Hash to CID (manifest type): bah5acgzaitxyvem2pivg7y3hclkfcich3nagzr5mlqdnu5zr4dfypovrb74q  ","version":"Next","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}