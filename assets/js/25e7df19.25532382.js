"use strict";(self.webpackChunkbee_js_docs=self.webpackChunkbee_js_docs||[]).push([[1676],{8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}},9290:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"documentation/gsoc","title":"GSOC","description":"The GSOC (Graffiti Several Owner Chunk) feature allows a full node to receive messages from many other nodes using a shared Single Owner Chunk (SOC). This enables real-time messaging over Swarm.","source":"@site/docs/documentation/gsoc.md","sourceDirName":"documentation","slug":"/gsoc","permalink":"/docs/gsoc","draft":false,"unlisted":false,"editUrl":"https://github.com/ethersphere/bee-js-docs/docs/documentation/gsoc.md","tags":[],"version":"current","frontMatter":{"title":"GSOC","id":"gsoc","slug":"/gsoc","sidebar_label":"GSOC"},"sidebar":"Balls","previous":{"title":"PSS","permalink":"/docs/pss"},"next":{"title":"SOC and Feeds","permalink":"/docs/soc-and-feeds"}}');var r=s(4848),t=s(8453);const d={title:"GSOC",id:"gsoc",slug:"/gsoc",sidebar_label:"GSOC"},a=void 0,o={},c=[{value:"Overview",id:"overview",level:2},{value:"GSOC vs PSS",id:"gsoc-vs-pss",level:3},{value:"Requirements",id:"requirements",level:2},{value:"Create an Identifier (Receiver and Sender)",id:"create-an-identifier-receiver-and-sender",level:2},{value:"Get Target Overlay (Receiver Node)",id:"get-target-overlay-receiver-node",level:2},{value:"Set Up a Listener (Receiver Node)",id:"set-up-a-listener-receiver-node",level:2},{value:"Send a Message (Sender Node)",id:"send-a-message-sender-node",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The GSOC (Graffiti Several Owner Chunk) feature allows a ",(0,r.jsx)(n.strong,{children:"full node"})," to receive messages from many other nodes using a shared Single Owner Chunk (SOC). This enables real-time messaging over Swarm."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["GSOC messages are updates to a pre-mined SOC that lands in the ",(0,r.jsx)(n.strong,{children:"neighborhood"})," of the recipient node. Only full nodes receive these updates because light nodes do not sync neighborhood chunks. However, ",(0,r.jsx)(n.strong,{children:"any node"})," (light or full) can send GSOC messages."]}),"\n",(0,r.jsx)(n.h3,{id:"gsoc-vs-pss",children:"GSOC vs PSS"}),"\n",(0,r.jsx)(n.p,{children:"GSOC shares some similarities with PSS - both features allow for full nodes to receive messages from other nodes."}),"\n",(0,r.jsx)(n.p,{children:"However, there are several key differences:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Unlike PSS, ",(0,r.jsx)(n.strong,{children:"GSOC only needs to mine the target chunk once"}),"\u2014multiple messages reuse it, making it ",(0,r.jsx)(n.strong,{children:"faster, cheaper"}),", and ",(0,r.jsx)(n.strong,{children:"more efficient"})," for recurring updates."]}),"\n",(0,r.jsxs)(n.li,{children:["Unlike PSS, ",(0,r.jsx)(n.strong,{children:"No encryption"})," is used by default, making it unsuitable for handling sensitive data."]}),"\n",(0,r.jsxs)(n.li,{children:["Unlike PSS, ",(0,r.jsx)(n.strong,{children:"GSOC chunks are not meant to be retrieved directly"}),". The SOC used to initiate a GSOC connection is used to listen for incoming messages only, the chunk itself is not meant to be retrieved since the incoming messages are not actually used to update the SOC since double-signing an SOC is undefined behavior."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsx)(n.p,{children:"To use the example scripts below, you need:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A Bee full node with a fully synced reserve for receiving GSOC messages."}),"\n",(0,r.jsx)(n.li,{children:"A light node for sending GSOC messages."}),"\n",(0,r.jsxs)(n.li,{children:["The batch ID of a usable postage batch. If you don't have one already, you will need to ",(0,r.jsx)(n.a,{href:"/docs/storage/#purchasing-storage",children:"buy a batch"})," to upload data. If you do have one, you will need to ",(0,r.jsx)(n.a,{href:"/docs/storage/#selecting-a-batch",children:"get and save"})," its batch ID."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"create-an-identifier-receiver-and-sender",children:"Create an Identifier (Receiver and Sender)"}),"\n",(0,r.jsx)(n.p,{children:"Identifiers in GSOC are similar to topics in PSS \u2014 they define the stream of messages a receiver node is subscribed to. The sender must use the same identifier so that their messages are received."}),"\n",(0,r.jsxs)(n.p,{children:["Each identifier is a 32 byte (64-digit) hex string. It can be initialized with a 32 byte hex string of your choice or can be created from any arbitrary string using the ",(0,r.jsx)(n.code,{children:"Identifier"})," utility class. You can also use the zero-initialized ",(0,r.jsx)(n.code,{children:"NULL_IDENTIFIER"})," as a default identifier for cases where you don't need a unique identifier:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Identifier, NULL_IDENTIFIER } from '@ethersphere/bee-js'\n\n// Use default (all zeros):\nconst identifier = NULL_IDENTIFIER\n\n// From a hex string:\nconst identifier = new Identifier('6527217e549e84f98e51b1d8b1ead62ff5cad59acd9713825754555d6975f103')\n\n// From a human-readable string:\nconst identifier = Identifier.fromString('chat:v1')\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"NULL_IDENTIFIER"})," is a 64 digit hex string of all zeros - use it for quick testing or when uniqueness doesn't matter."]}),"\n",(0,r.jsxs)(n.li,{children:["Use any hex string to initialize a new ",(0,r.jsx)(n.code,{children:"Identifier"})," object ."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"Identifier.fromString()"})," to generate an identifier derived from your string of choice (allows for easy to remember human readable identifiers ",(0,r.jsx)(n.code,{children:'"notifications"'}),", ",(0,r.jsx)(n.code,{children:'"chat:user1"'}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"get-target-overlay-receiver-node",children:"Get Target Overlay (Receiver Node)"}),"\n",(0,r.jsxs)(n.p,{children:["This step ",(0,r.jsx)(n.strong,{children:"is performed by the receiving full node"})," to retrieve its overlay address. This overlay address is then shared with the sender node to use as a target overlay for its GSOC messages:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Bee } from '@ethersphere/bee-js'\n\nconst bee = new Bee('http://localhost:1633')\n\nasync function checkAddresses() {\n  const addresses = await bee.getNodeAddresses()\n  console.log('Node Addresses:', addresses)\n}\n\ncheckAddresses()\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"Node Addresses:\nOverlay: 1e2054bec3e681aeb0b365a1f9a574a03782176bd3ec0bcf810ebcaf551e4070\nEthereum: 9a73f283cd9211b96b5ec63f7a81a0ddc847cd93\nPublic Key: 7d0c4759f689ea3dd3eb79222870671c492cb99f3fade275bcbf0ea39cd0ef6e25edd43c99985983e49aa528f3f2b6711085354a31acb4e7b03559b02ec868f0\nPSS Public Key: 5ade58d20be7e04ee8f875eabeebf9c53375a8fc73917683155c7c0b572f47ef790daa3328f48482663954d12f6e4739f748572c1e86bfa89af99f17e7dd4d33\nUnderlay: [\n  '/ip4/127.0.0.1/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j',\n  '/ip4/172.17.0.2/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j',\n  '/ip6/::1/tcp/1634/p2p/QmcpSJPHuuQYRgDkNfwziihVcpuVteoNxePvfzaJyp9z7j'\n]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Overlay"})," should be saved and shared with sender nodes."]}),"\n",(0,r.jsx)(n.h2,{id:"set-up-a-listener-receiver-node",children:"Set Up a Listener (Receiver Node)"}),"\n",(0,r.jsx)(n.p,{children:"This must be run on a full node. It mines a key that lands within its own neighborhood and starts listening."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Bee, Identifier, NULL_IDENTIFIER } from '@ethersphere/bee-js'\n\nconst bee = new Bee('http://localhost:1633')\nconst identifier = Identifier.fromString(NULL_IDENTIFIER)\n\nasync function listen() {\n  const { overlay } = await bee.getNodeAddresses()\n\n  // The signer is initialized using the receiving node's own overlay and chosen identifier\n  const signer = bee.gsocMine(overlay, identifier)\n\n  // A GSOC subscription is established using the blockchain address derived from the signer and the identifier\n  bee.gsocSubscribe(signer.publicKey().address(), identifier, {\n    // A callback function is used to handle incoming updates - you can include your application logic here\n    onMessage: message => console.log('Received:', message.toUtf8()),\n    onError: error => console.error('Subscription error:', error),\n  })\n\n  console.log('Listening for GSOC updates...')\n}\n\nlisten()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"send-a-message-sender-node",children:"Send a Message (Sender Node)"}),"\n",(0,r.jsxs)(n.p,{children:["The sending node must have a ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"usable postage batch id"})})," and also know the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"target overlay address"})})," and ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"identifier"})})," in order to send a message:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Bee, Identifier, NULL_IDENTIFIER } from '@ethersphere/bee-js'\n\nconst bee = new Bee('http://localhost:1643')\n\n// The identifier is initialized using the same data as the receiving node\nconst identifier = Identifier.fromString(NULL_IDENTIFIER)\nconst batchId = '6c84b6d3f5273b969c3df875cde7ccd9920f5580122929aedaf440bfe4484405'\n\nconst recipientOverlay = '1e2054bec3e681aeb0b365a1f9a574a03782176bd3ec0bcf810ebcaf551e4070'\n\nasync function sendMessage() {\n  // The signer is initialized using the overlay address and identifier shared by the receiving node \n  const signer = bee.gsocMine(recipientOverlay, identifier)\n\n  // bee.gsocSend() is called with the batch id, initialized signer, identifier, and message payload in order to send a GSOC message\n  await bee.gsocSend(batchId, signer, identifier, 'Hello via GSOC!')\n  console.log('Message sent')\n}\n\nsendMessage()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For more information about GSOC, refer to the ",(0,r.jsx)(n.a,{href:"https://docs.ethswarm.org/docs/develop/tools-and-features/gsoc",children:"Bee documentation"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);