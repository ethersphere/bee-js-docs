"use strict";(self.webpackChunkbee_js_docs=self.webpackChunkbee_js_docs||[]).push([[152],{5537:(e,n,t)=>{t.d(n,{A:()=>v});var r=t(6540),s=t(4164),a=t(5627),i=t(6347),o=t(372),d=t(604),l=t(1861),c=t(8749);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const s=(0,i.W6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,d.aZ)(a),(0,r.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=u(e),[i,d]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:a}))),[l,h]=f({queryString:t,groupId:s}),[x,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,a]=(0,c.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:s}),m=(()=>{const e=l??x;return p({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{m&&d(m)}),[m]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),g(e)}),[h,g,a]),tabValues:a}}var g=t(9136);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=t(4848);function y(e){let{className:n,block:t,selectedValue:r,selectValue:i,tabValues:o}=e;const d=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),c=e=>{const n=e.currentTarget,t=d.indexOf(n),s=o[t].value;s!==r&&(l(n),i(s))},h=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>{d.push(e)},onKeyDown:h,onClick:c,...a,className:(0,s.A)("tabs__item",m.tabItem,a?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function b(e){const n=x(e);return(0,w.jsxs)("div",{className:(0,s.A)("tabs-container",m.tabList),children:[(0,w.jsx)(y,{...n,...e}),(0,w.jsx)(j,{...n,...e})]})}function v(e){const n=(0,g.A)();return(0,w.jsx)(b,{...e,children:h(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var r=t(4164);const s={tabItem:"tabItem_Ymn6"};var a=t(4848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,i),hidden:t,children:n})}},9466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"documentation/soc-and-feeds","title":"SOC and Feeds","description":"Swarm provides the ability to store content in content-addressed chunks (CAC) whose addresses are derived from the chunk data, or Single Owner Chunks (SOC) whose addresses are derived from the uploader\'s address and chosen identifier. With single owner chunks, a user can assign arbitrary data to an address and attest chunk integrity with their digital signature.","source":"@site/docs/documentation/soc-and-feeds.md","sourceDirName":"documentation","slug":"/soc-and-feeds","permalink":"/docs/soc-and-feeds","draft":false,"unlisted":false,"editUrl":"https://github.com/ethersphere/bee-js-docs/docs/documentation/soc-and-feeds.md","tags":[],"version":"current","frontMatter":{"title":"SOC and Feeds","id":"soc-and-feeds","slug":"/soc-and-feeds","sidebar_label":"SOC and Feeds"},"sidebar":"Balls","previous":{"title":"GSOC","permalink":"/docs/gsoc"},"next":{"title":"ACT","permalink":"/docs/act"}}');var s=t(4848),a=t(8453);t(5537),t(9329);const i={title:"SOC and Feeds",id:"soc-and-feeds",slug:"/soc-and-feeds",sidebar_label:"SOC and Feeds"},o=void 0,d={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Single Owner Chunks",id:"single-owner-chunks",level:2},{value:"Uploading SOCs",id:"uploading-socs",level:3},{value:"Retrieving SOCs",id:"retrieving-socs",level:3},{value:"Feeds",id:"feeds",level:2},{value:"Concepts",id:"concepts",level:3},{value:"Creating and Updating Feeds Using Topics",id:"creating-and-updating-feeds-using-topics",level:3},{value:"Retrieving from Feeds by Topic and Owner",id:"retrieving-from-feeds-by-topic-and-owner",level:3},{value:"Using Feed Manifests for Fixed References",id:"using-feed-manifests-for-fixed-references",level:3},{value:"Non-Sequential Feed Updates (Discouraged)",id:"non-sequential-feed-updates-discouraged",level:3}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Swarm provides the ability to store content in content-addressed ",(0,s.jsx)(n.a,{href:"https://docs.ethswarm.org/docs/concepts/DISC/#content-addressed-chunks-and-single-owner-chunks",children:"chunks"})," (CAC) whose addresses are derived from the chunk data, or Single Owner Chunks (SOC) whose addresses are derived from the uploader's address and chosen identifier. With single owner chunks, a user can assign arbitrary data to an address and attest chunk integrity with their digital signature."]}),"\n",(0,s.jsxs)(n.p,{children:["Feeds are a unique feature of Swarm which simulate the publishing of mutable content on Swarm's immutable storage. ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"Feeds constitute the primary use case for SOCs."})})," Developers can use Feeds to version revisions of a mutable resource by indexing sequential updates to a topic at predictably calculated addresses. Because Feeds are built on top of SOCs, their interfaces are somewhat similar and use common concepts."]}),"\n",(0,s.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(n.p,{children:"Interactions with SOC and feeds requires the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A fully initialized Bee light node running with fully synced postage batch data. (Running at ",(0,s.jsx)(n.code,{children:"http://localhost:1633"})," by default)"]}),"\n",(0,s.jsx)(n.li,{children:"A valid postage batch ID."}),"\n",(0,s.jsx)(n.li,{children:"An Ethereum-compatible private key to sign updates. Using your node or blockchain account wallet's private key is strongly discouraged. Using a dedicated key for SOC / feeds is recommended."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"single-owner-chunks",children:"Single Owner Chunks"}),"\n",(0,s.jsxs)(n.p,{children:["Bee-js calculates a SOC Swarm reference hash as the keccak256 hash of the concatenation of the  ",(0,s.jsx)(n.code,{children:"identifier"})," and ",(0,s.jsx)(n.code,{children:"owner"})," Ethereum address. The ",(0,s.jsx)(n.code,{children:"identifier"})," is a 32 byte long arbitrary value (by default a hex string or a ",(0,s.jsx)(n.code,{children:"Uint8Array"}),"). The ",(0,s.jsx)(n.code,{children:"owner"})," is an Ethereum address that consists of 20 bytes in a format of a hex string or ",(0,s.jsx)(n.code,{children:"Uint8Array"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["SOCs are powerful and flexible low-level feature which provide the foundation upon which higher level abstractions such as ",(0,s.jsx)(n.a,{href:"/docs/gsoc/",children:"GSOC"})," and ",(0,s.jsx)(n.a,{href:"/docs/soc-and-feeds/#feeds",children:"feeds"})," are built. For most common use cases developers are recommended to use these higher level abstractions rather than interacting directly with SOCs themselves."]})}),"\n",(0,s.jsx)(n.admonition,{title:"SOCs are immutable!",type:"warning",children:(0,s.jsxs)(n.p,{children:['You might be tempted to modify a SOC\'s content to "update" the chunk. Reuploading of an SOC is discouraged as its behavior is undefined. Either use a different ',(0,s.jsx)(n.code,{children:"identifier"}),", or you might be looking for feeds if you need to perform multiple updates to the same content."]})}),"\n",(0,s.jsx)(n.h3,{id:"uploading-socs",children:"Uploading SOCs"}),"\n",(0,s.jsxs)(n.p,{children:["To write a Single Owner Chunk (SOC), use the ",(0,s.jsx)(n.code,{children:"makeSOCWriter()"})," method from the Bee client. This method requires a signer, which can be an instance of ",(0,s.jsx)(n.code,{children:"PrivateKey"}),", a raw Ethereum private key as a hex string (with or without the ",(0,s.jsx)(n.code,{children:"0x"})," prefix), or a ",(0,s.jsx)(n.code,{children:"Uint8Array"})," representing the private key."]}),"\n",(0,s.jsx)(n.p,{children:"The signer is used to cryptographically sign the chunk, using the same format Ethereum uses for signing transactions."}),"\n",(0,s.jsxs)(n.p,{children:["Once the ",(0,s.jsx)(n.code,{children:"SOCWriter"})," is created, you can upload an SOC by providing a ",(0,s.jsx)(n.code,{children:"postageBatchId"}),", a 32-byte ",(0,s.jsx)(n.code,{children:"identifier"}),", and the ",(0,s.jsx)(n.code,{children:"data"})," payload."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["Default ",(0,s.jsx)(n.code,{children:"signer"})]}),(0,s.jsxs)(n.p,{children:["When you are instantiating ",(0,s.jsx)(n.code,{children:"Bee"})," class you can pass an Ethereum private key as the default signer that will be used if you won't specify it directly for the ",(0,s.jsx)(n.code,{children:"makeSOCWriter"}),"."]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Your assets and/or privacy may be at risk",type:"warning",children:(0,s.jsx)(n.p,{children:"We suggest using ephemeral private keys (e.g. randomly generated) when writing to SOC or Feeds. Never use your real Ethereum private keys here (or in any web applications) directly because it will allow others to sign messages with your kay which may compromise your privacy or lead to the loss of funds stored by that account."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { Bee, PrivateKey, NULL_IDENTIFIER, Bytes } from "@ethersphere/bee-js"\n\n// Define your Ethereum private key (don\'t use your node\'s or real wallet\'s private keys)\nconst privateKey = new PrivateKey(\'0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd\')\n\n// Print the identifier and address which can be used to retrieve the SOC\nconsole.log("SOC identifier")\nconsole.log(new Bytes(NULL_IDENTIFIER).toHex())\n\n// Print Ethereum address\nconsole.log("Ethereum address")\nconsole.log(privateKey.publicKey().address().toHex())\n\n// Initialize Bee client with default signer and Swarm node URL\nconst bee = new Bee(\'http://localhost:1643\', { signer: privateKey })\n\n// Replace with your own valid postage batch ID here\nconst postageBatchId = \'f2949db4cfa4f5140ed3ef29f651d189175a8cb9534c992d3c3212b17f0b67f7\'\n\n// Create the SOC writer\nconst socWriter = bee.makeSOCWriter(privateKey)\n\n// The data you want to store in the SOC\nconst data = \'this is my sample data\'\n\nasync function uploadSOC() {\n  try {\n    // Upload the data to the SOC using the postage batch and identifier\n    const response = await socWriter.upload(postageBatchId, NULL_IDENTIFIER, data)\n\n    // Log the human-readable reference (hex string)\n    console.log("SOC reference:")\n    console.log("Reference (Hex):", response.reference.toHex())\n  } catch (error) {\n    // Handle any errors during the upload\n    console.error("Error uploading SOC:", error)\n  }\n}\n\n// Call the function to write the SOC\nuploadSOC()\n'})}),"\n",(0,s.jsx)(n.p,{children:"Example output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"SOC identifier\n0000000000000000000000000000000000000000000000000000000000000000\nEthereum address\n8d3766440f0d7b949a5e32995d09619a7f86e632\nSOC reference:\nReference (Hex): 9d453ebb73b2fedaaf44ceddcf7a0aa37f3e3d6453fea5841c31f0ea6d61dc85\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"privateKey"})," is used to initialize the writer as ",(0,s.jsx)(n.code,{children:"socWriter"})," which is used to sign the SOC."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NULL_IDENTIFIER"})," is the 32-byte value used as the identifier (can be replaced with any user-defined value)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"socWriter.upload()"})," signs and uploads the data, returning a ",(0,s.jsx)(n.code,{children:"reference"})," as confirmation."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"identifier"})," and Ethereum address together determine the SOC address and must match exactly when retrieving the chunk later. The returned ",(0,s.jsx)(n.code,{children:"reference"})," is included as part of the upload response, but unlike non-SOC uploads, the returned reference is not used to retrieve the chunk, rather the ",(0,s.jsx)(n.code,{children:"identifier"})," and Ethereum address are used (see next section for example usage)."]}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-socs",children:"Retrieving SOCs"}),"\n",(0,s.jsxs)(n.p,{children:["To retrieve a previously uploaded SOC, you must know the Ethereum address of the owner (the signer used to upload the SOC) and the exact 32-byte ",(0,s.jsx)(n.code,{children:"identifier"})," used during upload. These two values uniquely determine the SOC address in Swarm."]}),"\n",(0,s.jsxs)(n.p,{children:["To download a SOC in Bee-JS, use the ",(0,s.jsx)(n.code,{children:"makeSOCReader()"})," method. This method takes the owner's Ethereum address (as a ",(0,s.jsx)(n.code,{children:"EthAddress"})," instance, a hex string, or a ",(0,s.jsx)(n.code,{children:"Uint8Array"}),") and returns a ",(0,s.jsx)(n.code,{children:"SOCReader"})," object. You can then call ",(0,s.jsx)(n.code,{children:".download(identifier)"})," on the reader to retrieve the chunk's data."]}),"\n",(0,s.jsx)(n.admonition,{title:"SOC address is derived from the identifier and owner",type:"info",children:(0,s.jsxs)(n.p,{children:["Unlike uploads using content addressed chunks which are retrieved by their Swarm reference hash, SOCs are retrieved using the combination of ",(0,s.jsx)(n.code,{children:"identifier"})," and ",(0,s.jsx)(n.code,{children:"owner"}),", not their Swarm reference hash."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { Bee, Size, NULL_IDENTIFIER } from "@ethersphere/bee-js"\n\n// Initialize Bee client pointing to the Swarm node\nconst bee = new Bee(\'http://localhost:1633\')\n\n// The owner\'s Ethereum address (20 bytes)\nconst owner = \'8d3766440f0d7b949a5e32995d09619a7f86e632\'\n\n// Create a SOC reader object bound to the owner\nconst socReader = bee.makeSOCReader(owner)\n\nasync function readSOC() {\n  try {\n    // Download the SOC using the identifier\n    const response = await socReader.download(NULL_IDENTIFIER)\n\n    // Log the data\n    console.log("SOC Data:", response.payload.toUtf8())\n\n    // Optionally, you can use the data in other ways (e.g., process, display, etc.)\n  } catch (error) {\n    // Handle any errors during download\n    console.error("Error downloading SOC:", error)\n  }\n}\n\n// Call the function to read the SOC\nreadSOC()\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"owner"})," is the Ethereum address used to sign the SOC."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NULL_IDENTIFIER"})," is the same default identifier used in the earlier upload example."]}),"\n",(0,s.jsxs)(n.li,{children:["The returned payload is a ",(0,s.jsx)(n.code,{children:"Bytes"})," object, and ",(0,s.jsx)(n.code,{children:".toUtf8()"})," converts it to a human-readable string."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Make sure the ",(0,s.jsx)(n.code,{children:"owner"})," and ",(0,s.jsx)(n.code,{children:"identifier"})," values match exactly what was used during upload \u2014 any mismatch will result in the chunk not being found."]}),"\n",(0,s.jsx)(n.h2,{id:"feeds",children:"Feeds"}),"\n",(0,s.jsxs)(n.p,{children:["Feeds are an abstraction built on top of Single Owner Chunks (SOCs) that ",(0,s.jsx)(n.strong,{children:"simulate mutable content"})," in Swarm. They enable sequenced updates over time while maintaining a stable access point. Feeds are ideal for dynamic content like apps, messages, or websites. Each update is stored in a new immutable chunk at a deterministically calculated address."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'Although feeds appear "mutable," no data is ever modified\u2014new updates are simply written to new indexes.'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Similar to how an SOC is defined by an ",(0,s.jsx)(n.code,{children:"owner"})," and ",(0,s.jsx)(n.code,{children:"identifier"}),", a feed is defined by:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"owner"}),": an Ethereum-compatible address"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"topic"}),": a unique 32-byte identifier"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Feed Writing"}),": Publishers sign and write updates associated with specific topics to specific indices using their private key."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Append-Only Behavior and Index Resolution"}),": Feeds are typically used in an append-only fashion, though skipping indices is possible. However, the latest update is resolved as the highest ",(0,s.jsx)(n.em,{children:"consecutive"})," index. Updates at non-consecutively written indices must be retrieved explicitly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No Overwriting"}),": Each index can be written only once. Updates are permanent."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Feed Reading"}),": Readers resolve updates using the ",(0,s.jsx)(n.code,{children:"owner"})," and ",(0,s.jsx)(n.code,{children:"topic"}),". By default, if no index is specified they fetch the latest consecutively written index."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Payloads"}),": Feed payloads include strings, JSON, or Swarm references. Payload size is limited to a single 4\u202fKB chunk."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-and-updating-feeds-using-topics",children:"Creating and Updating Feeds Using Topics"}),"\n",(0,s.jsxs)(n.p,{children:["This script demonstrates how to create two distinct feeds using different topics and update them using two methods: ",(0,s.jsx)(n.code,{children:"uploadPayload()"})," and ",(0,s.jsx)(n.code,{children:"upload()"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"upload()"})}),": Used for uploading references to other content on Swarm."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"uploadPayload()"})}),": Directly stores an arbitrary data payload in the feed."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Although it is possible to update feeds with an arbitrary data payload using ",(0,s.jsx)(n.code,{children:"uploadPayload()"}),", for most use cases the content should be uploaded separately (such as with ",(0,s.jsx)(n.code,{children:"bee.uploadFile()"}),"), and the feed will be updated with the reference of that upload using the ",(0,s.jsx)(n.code,{children:"upload()"})," method."]}),"\n",(0,s.jsx)(n.p,{children:"The script below performs the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes the Bee client and derives the feed owner address from a private key."}),"\n",(0,s.jsxs)(n.li,{children:["Uses the ",(0,s.jsx)(n.code,{children:"uploadPayload()"})," method to upload a plain text string as a ",(0,s.jsx)(n.strong,{children:"payload update"})," to the feed with topic ",(0,s.jsx)(n.code,{children:'"payload-update"'}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Uploads the same string as a file to Swarm and obtains a reference."}),"\n",(0,s.jsxs)(n.li,{children:["Uses the ",(0,s.jsx)(n.code,{children:"upload()"})," method to upload the obtained reference as a ",(0,s.jsx)(n.strong,{children:"reference update"})," to the feed with topic ",(0,s.jsx)(n.code,{children:'"reference-update"'}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { Bee, Topic, PrivateKey } from '@ethersphere/bee-js'\n\nconst BEE_URL = 'http://localhost:1643'\n\n// Make sure to replace with a valid batch ID\nconst POSTAGE_BATCH_ID = 'c119705f257c0015a062b17929e3ca3269e158231324707f2ea6e72c5c9f9b78'\n\n// Any Ethereum style private key can be used, ideally dedicated to this feed only. Using your node or wallet's key is strongly discouraged.\nconst privateKey = new PrivateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')\nconst bee = new Bee(BEE_URL)\nconst owner = privateKey.publicKey().address()\n\n// This owner address can be shared along with the topic to enable anyone to retrieve updates from the feed\nconsole.log('Feed owner address:')\nconsole.log(owner.toHex())\n\nasync function run() {\n  const message = 'This is a test announcement.'\n  const topic1 = Topic.fromString('payload-update')\n\n  // The writer is constructed from the topic and private key, and can be used for writing feed updates (it also supports reading from feeds)\n  const writer1 = bee.makeFeedWriter(topic1, privateKey)\n\n  await writer1.uploadPayload(POSTAGE_BATCH_ID, message)\n  console.log('\u2705 First feed updated with payload.')\n\n  const result = await bee.uploadFile(POSTAGE_BATCH_ID, message, 'announcement.txt')\n  console.log(result)\n  console.log(result.reference.toHex())\n\n  // The second writer is constructed using a new topic and the same private key\n  const topic2 = Topic.fromString('reference-update')\n  const writer2 = bee.makeFeedWriter(topic2, privateKey)\n  await writer2.upload(POSTAGE_BATCH_ID, result.reference)\n  console.log('\u2705 Second feed updated with reference.')\n}\n\nrun().catch(console.error)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-from-feeds-by-topic-and-owner",children:"Retrieving from Feeds by Topic and Owner"}),"\n",(0,s.jsxs)(n.p,{children:["This script demonstrates how to retrieve data from feeds using their ",(0,s.jsx)(n.code,{children:"topic"})," and ",(0,s.jsx)(n.code,{children:"owner"}),". There are two primary methods used for reading from feeds:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"downloadPayload()"})})," \u2013 Used to read the raw payload written directly to the feed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"downloadReference()"})})," \u2013 Used to read a Swarm reference from the feed. The returned reference can then be passed to ",(0,s.jsx)(n.code,{children:"downloadFile()"})," to retrieve the associated file."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The script performs the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes the Bee client and derives the feed owner address from a private key."}),"\n",(0,s.jsxs)(n.li,{children:["Reads the latest ",(0,s.jsx)(n.strong,{children:"payload update"})," from the feed with topic ",(0,s.jsx)(n.code,{children:'"payload-update"'})," using ",(0,s.jsx)(n.code,{children:"downloadPayload()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Reads the latest ",(0,s.jsx)(n.strong,{children:"reference update"})," from the feed with topic ",(0,s.jsx)(n.code,{children:'"reference-update"'})," using ",(0,s.jsx)(n.code,{children:"downloadReference()"}),", then retrieves the associated file from Swarm using ",(0,s.jsx)(n.code,{children:"downloadFile()"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Feed readers always require a topic and an owner address. By default, they fetch the latest ",(0,s.jsx)(n.em,{children:"consecutively written"})," update. To retrieve a specific update, an explicit index can be provided."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"While not explicitly enforced, it is strongly recommended to use feeds in an append-only fashion. If instead non-consecutive updates are performed, the only way to discover updates at higher non-consecutively written indexes is to iterate one by one through all indexes up to the number of the index with the update."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { Bee, Topic, PrivateKey } from '@ethersphere/bee-js'\n\nconst BEE_URL = 'http://localhost:1643'\n\nasync function run() {\n  const bee = new Bee(BEE_URL)\n  const privateKey = new PrivateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')\n  const owner = privateKey.publicKey().address()\n\n  // Read from payload-update feed\n  const topic1 = Topic.fromString('payload-update')\n  const reader1 = bee.makeFeedReader(topic1, owner)\n\n  console.log('\\n Reading latest update for feed: \"payload-update\"')\n\n  try {\n    const latest = await reader1.downloadPayload()\n    const text = latest.payload.toUtf8()\n\n    console.log('Message (as plain text):', text)\n    console.log('Feed index:', BigInt(`0x${Buffer.from(latest.feedIndex.bytes).toString('hex')}`))\n    console.log('Next index:', BigInt(`0x${Buffer.from(latest.feedIndexNext.bytes).toString('hex')}`))\n  } catch (error) {\n    console.warn('\u274c Failed to read update:', error.message)\n  }\n\n  // Read from reference-update feed\n  const topic2 = Topic.fromString('reference-update')\n  const reader2 = bee.makeFeedReader(topic2, owner)\n\n  console.log('\\n Reading latest update for feed: \"reference-update\"')\n\n  try {\n    const latest = await reader2.downloadReference()\n    const referenceHex = latest.reference.toHex()\n\n    console.log('Swarm reference (hex):', referenceHex)\n\n    const file = await bee.downloadFile(referenceHex)\n    console.log('Retrieved file content:', file.data.toUtf8())\n    console.log('Feed index:', BigInt(`0x${Buffer.from(latest.feedIndex.bytes).toString('hex')}`))\n    console.log('Next index:', BigInt(`0x${Buffer.from(latest.feedIndexNext.bytes).toString('hex')}`))\n  } catch (error) {\n    console.warn('\u274c Failed to read update:', error.message)\n  }\n}\n\nrun().catch(console.error)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-feed-manifests-for-fixed-references",children:"Using Feed Manifests for Fixed References"}),"\n",(0,s.jsxs)(n.p,{children:["Feed manifests allow you to expose a feed through a ",(0,s.jsx)(n.strong,{children:"stable Swarm reference"})," that always resolves to the latest update. This is especially useful for hosting evolving content like websites or files, without needing to share a new Swarm reference each time content changes."]}),"\n",(0,s.jsx)(n.p,{children:"With a manifest, you can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Retrieve the ",(0,s.jsx)(n.strong,{children:"latest feed update"})," through a static ",(0,s.jsx)(n.code,{children:"/bzz/<manifestReference>/"})," URL."]}),"\n",(0,s.jsxs)(n.li,{children:["Share a single reference that always resolves to the ",(0,s.jsx)(n.strong,{children:"current content"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Enable compatibility with public gateways and ENS domains."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The script below performs the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes the Bee client and creates a feed manifest using a topic and owner."}),"\n",(0,s.jsx)(n.li,{children:"Checks the current feed index or starts from index 0."}),"\n",(0,s.jsx)(n.li,{children:"Uploads two updates to Swarm and stores their references in the feed at consecutive indices."}),"\n",(0,s.jsx)(n.li,{children:"After each update, retrieves the content using the same manifest reference, confirming it resolves to the latest."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { Bee, Topic, PrivateKey, FeedIndex } from '@ethersphere/bee-js'\n\nconst BEE_URL = 'http://localhost:1643'\nconst POSTAGE_BATCH_ID = 'c119705f257c0015a062b17929e3ca3269e158231324707f2ea6e72c5c9f9b78'\n\nconst bee = new Bee(BEE_URL)\nconst privateKey = new PrivateKey('0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef')\nconst owner = privateKey.publicKey().address()\n\nconsole.log('Feed owner:', owner.toHex())\n\nconst topic = Topic.fromString('uploaded-reference-demo')\nconst manifestReference = await bee.createFeedManifest(POSTAGE_BATCH_ID, topic, owner)\nconsole.log('\\n Manifest created:')\nconsole.log('Ref:', manifestReference.toString())\nconsole.log('URL:', `${BEE_URL}/bzz/${manifestReference.toString()}/`)\n\nconst reader = bee.makeFeedReader(topic, owner)\nlet index\ntry {\n  const latest = await reader.download()\n  index = latest.feedIndexNext\n  const latestIndex = BigInt(`0x${Buffer.from(latest.feedIndex.bytes).toString('hex')}`)\n  console.log(`\\n Latest index: ${latestIndex}`)\n} catch {\n  index = FeedIndex.fromBigInt(0n)\n  console.log('\\n No updates yet. Starting at index 0')\n}\n\nfor (let i = 0; i < 2; i++) {\n  const content = `Update ${BigInt(`0x${Buffer.from(index.bytes).toString('hex')}`)}`\n  const upload = await bee.uploadFile(POSTAGE_BATCH_ID, content, `update-${i}.txt`)\n  const writer = bee.makeFeedWriter(topic, privateKey)\n  await writer.upload(POSTAGE_BATCH_ID, upload.reference, { index })\n\n  console.log(`\\n\u2705 Updated to index ${BigInt(`0x${Buffer.from(index.bytes).toString('hex')}`)}: \"${content}\"`)\n\n  const result = await bee.downloadFile(manifestReference)\n  console.log(` Retrieved via manifest: \"${result.data.toUtf8()}\"`)\n  console.log(`URL: ${BEE_URL}/bzz/${manifestReference.toString()}/`)\n\n  index = index.next()\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"non-sequential-feed-updates-discouraged",children:"Non-Sequential Feed Updates (Discouraged)"}),"\n",(0,s.jsxs)(n.p,{children:["Although feeds are typically updated in a sequential, append-only manner, it is possible to manually write to a specific index using the ",(0,s.jsx)(n.code,{children:"index"})," option. However, only the ",(0,s.jsx)(n.strong,{children:"highest consecutively filled index"})," is considered the latest. Any gaps will result in newer updates at higher indices being ignored when resolving the latest feed content."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"await writer.uploadPayload(POSTAGE_BATCH_ID, 'Initial update') // Goes to index 0\nawait writer.uploadPayload(POSTAGE_BATCH_ID, 'Out-of-order update', { index: 5 })\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, attempting to read the latest update without specifying an index will still return the update at index 0:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const latest = await reader.downloadPayload()\nconsole.log(latest.payload.toUtf8())\n// \u2192 "Initial update"\n'})}),"\n",(0,s.jsx)(n.p,{children:"To read the out-of-order update at index 5, you must explicitly specify it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const manual = await reader.downloadPayload({ index: 5 })\nconsole.log(manual.payload.toUtf8())\n// \u2192 "Out-of-order update"\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["Manually writing to skipped indices is supported but not recommended. It is recommended to use the default behavior when performing feed updates (no ",(0,s.jsx)(n.code,{children:"index"})," specified) to maintain a clean, append-only feed history and ensure new updates are easily discoverable."]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);