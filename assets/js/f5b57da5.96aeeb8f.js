"use strict";(self.webpackChunkbee_js_docs=self.webpackChunkbee_js_docs||[]).push([[152],{5537:(e,n,t)=>{t.d(n,{A:()=>v});var s=t(6540),a=t(4164),r=t(5627),i=t(6347),o=t(372),d=t(604),c=t(1861),l=t(8749);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:a}}=e;return{value:n,label:t,attributes:s,default:a}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const a=(0,i.W6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,d.aZ)(r),(0,s.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(a.location.search);n.set(r,e),a.replace({...a.location,search:n.toString()})}),[r,a])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=u(e),[i,d]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:r}))),[c,h]=f({queryString:t,groupId:a}),[m,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,r]=(0,l.Dv)(t);return[a,(0,s.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:a}),b=(()=>{const e=c??m;return p({value:e,tabValues:r})?e:null})();(0,o.A)((()=>{b&&d(b)}),[b]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),g(e)}),[h,g,r]),tabValues:r}}var g=t(9136);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function j(e){let{className:n,block:t,selectedValue:s,selectValue:i,tabValues:o}=e;const d=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),l=e=>{const n=e.currentTarget,t=d.indexOf(n),a=o[t].value;a!==s&&(c(n),i(a))},h=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:r}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>{d.push(e)},onKeyDown:h,onClick:l,...r,className:(0,a.A)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function w(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=m(e);return(0,x.jsxs)("div",{className:(0,a.A)("tabs-container",b.tabList),children:[(0,x.jsx)(j,{...n,...e}),(0,x.jsx)(w,{...n,...e})]})}function v(e){const n=(0,g.A)();return(0,x.jsx)(y,{...e,children:h(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var s=t(4164);const a={tabItem:"tabItem_Ymn6"};var r=t(4848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,i),hidden:t,children:n})}},9466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"documentation/soc-and-feeds","title":"SOC and Feeds","description":"\ud83d\udea7 Under Construction \ud83d\udea7","source":"@site/docs/documentation/soc-and-feeds.md","sourceDirName":"documentation","slug":"/soc-and-feeds","permalink":"/docs/soc-and-feeds","draft":false,"unlisted":false,"editUrl":"https://github.com/ethersphere/bee-js-docs/docs/documentation/soc-and-feeds.md","tags":[],"version":"current","frontMatter":{"title":"SOC and Feeds","id":"soc-and-feeds","slug":"/soc-and-feeds","sidebar_label":"SOC and Feeds"}}');var a=t(4848),r=t(8453);t(5537),t(9329);const i={title:"SOC and Feeds",id:"soc-and-feeds",slug:"/soc-and-feeds",sidebar_label:"SOC and Feeds"},o=void 0,d={},c=[{value:"\ud83d\udea7 Under Construction \ud83d\udea7",id:"-under-construction-",level:2},{value:"Single Owner Chunks",id:"single-owner-chunks",level:2},{value:"Reading SOCs",id:"reading-socs",level:3},{value:"Writing SOCs",id:"writing-socs",level:3},{value:"Feeds",id:"feeds",level:2},{value:"Topic",id:"topic",level:3},{value:"High level JSON API",id:"high-level-json-api",level:3},{value:"Low level API",id:"low-level-api",level:3},{value:"Reading feeds",id:"reading-feeds",level:4},{value:"Writing feeds",id:"writing-feeds",level:4},{value:"Using feed manifest",id:"using-feed-manifest",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"-under-construction-",children:"\ud83d\udea7 Under Construction \ud83d\udea7"}),"\n",(0,a.jsx)(n.admonition,{title:"\ud83d\udea7 This page is under construction",type:"caution",children:(0,a.jsx)(n.p,{children:"This section is still being worked on. Check back soon for updates!"})}),"\n","\n",(0,a.jsx)(n.p,{children:"Swarm provides the ability to store content in content-addressed chunks or Single Owner Chunks (SOC). With single owner chunks, a user can assign arbitrary data to an address and attest chunk integrity with their digital signature."}),"\n",(0,a.jsx)(n.p,{children:"Feeds are a unique feature of Swarm. They constitute the primary use case for single owner chunks. Developers can use Feeds to version revisions of a mutable resource, indexing sequential updates to a topic, publish the parts to streams, or post consecutive messages in a communication channel. Feeds implement persisted pull-messaging and can also be interpreted as a pub-sub system."}),"\n",(0,a.jsx)(n.p,{children:"Because Feeds are built on top of SOCs, their interfaces are somewhat similar and use common concepts."}),"\n",(0,a.jsx)(n.h2,{id:"single-owner-chunks",children:"Single Owner Chunks"}),"\n",(0,a.jsxs)(n.p,{children:["Bee-js calculates a SOC address as the hash of an ",(0,a.jsx)(n.code,{children:"identifier"})," and ",(0,a.jsx)(n.code,{children:"owner"}),". The ",(0,a.jsx)(n.code,{children:"identifier"})," is a 32 bytes long arbitrary data, usually expected as a hex string or a ",(0,a.jsx)(n.code,{children:"Uint8Array"}),". The ",(0,a.jsx)(n.code,{children:"owner"})," is an Ethereum address that consists of 20 bytes in a format of a hex string or  ",(0,a.jsx)(n.code,{children:"Uint8Array"}),"."]}),"\n",(0,a.jsx)(n.admonition,{title:"SOCs are immutable!",type:"warning",children:(0,a.jsxs)(n.p,{children:['You might be tempted to modify a SOC\'s content to "update" the chunk. Reuploading of SOC is forbidden in Swarm as it might create uncertain behavior. Bee node will reject the API call if it finds already existing SOC for the given address. Either use a different ',(0,a.jsx)(n.code,{children:"identifier"}),", or you might be looking for Feeds as your use case."]})}),"\n",(0,a.jsx)(n.h3,{id:"reading-socs",children:"Reading SOCs"}),"\n",(0,a.jsxs)(n.p,{children:["To read data from a SOC, we need to make a reader object bound to a specific ",(0,a.jsx)(n.code,{children:"owner"}),". Then we can download the data with the provided chunk's ",(0,a.jsx)(n.code,{children:"identifier"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632'\nconst socReader = bee.makeSOCReader(owner)\nconst identifier = '0000000000000000000000000000000000000000000000000000000000000000'\nconst soc = await socReader.download(identifier)\nconst data = soc.payload()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"writing-socs",children:"Writing SOCs"}),"\n",(0,a.jsxs)(n.p,{children:["When writing a SOC, first, we need to make a writer object. Because we need to sign the chunk, we need to pass in a ",(0,a.jsx)(n.code,{children:"signer"})," object. The ",(0,a.jsx)(n.code,{children:"signer"})," object can be either an Ethereum private key (as a hex string or ",(0,a.jsx)(n.code,{children:"Uint8Array"}),") or an instance of the ",(0,a.jsx)(n.code,{children:"Signer"})," interface. The ",(0,a.jsx)(n.code,{children:"Signer"})," interface can be used for integration with 3rd party Ethereum wallet applications because Swarm uses the same format for signing chunks that Ethereum uses for signing transactions."]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.mdxAdmonitionTitle,{children:["Default ",(0,a.jsx)(n.code,{children:"signer"})]}),(0,a.jsxs)(n.p,{children:["When you are instantiating ",(0,a.jsx)(n.code,{children:"Bee"})," class you can pass it a default signer that will be used if you won't specify it\ndirectly for the ",(0,a.jsx)(n.code,{children:"makeSOCWriter"}),". See ",(0,a.jsx)(n.code,{children:"Bee"})," constructor for more info."]})]}),"\n",(0,a.jsxs)(n.admonition,{title:"Ethereum Wallet signers",type:"tip",children:[(0,a.jsxs)(n.p,{children:["If you want to use your browser Ethereum Wallet like Metamask you can use utility called ",(0,a.jsx)(n.code,{children:"makeEthereumWalletSigner"}),"  that we ship with bee-js\nwhich creates a ",(0,a.jsx)(n.code,{children:"Signer"})," object out of given EIP-1193 compatible provider."]}),(0,a.jsxs)(n.p,{children:["See it used in our example ",(0,a.jsx)(n.a,{href:"https://github.com/ethersphere/examples-js/tree/master/eth-wallet-signing",children:"here"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { Utils } from '@ethersphere/bee-js'\n\nconst signer = Utils.makeEthereumWalletSigner(window.ethereum)\n...\n"})})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"type SyncSigner = (digest: Data) => Signature | string\ntype AsyncSigner = (digest: Data) => Promise<Signature | string>\n\n/**\n * Interface for implementing Ethereum compatible signing.\n *\n * @property sign     The sign function that can be sync or async\n * @property address  The Ethereum address of the signer\n */\nexport type Signer = {\n  sign: SyncSigner | AsyncSigner\n  address: EthAddress\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"Your communication privacy may be at risk",type:"warning",children:(0,a.jsxs)(n.p,{children:["We suggest using either ephemeral private keys (e.g. randomly generated) or the ",(0,a.jsx)(n.code,{children:"Signer"})," interface when writing to SOC or Feeds. Never use your real Ethereum private keys here (or in any web applications really) directly because you may lose your funds stored on it."]})}),"\n",(0,a.jsx)(n.p,{children:"Using the writer interface is similar to using the reader:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const postageBatchId = await bee.createPostageBatch(\"100\", 17)\nconst signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd'\nconst socWriter = bee.makeSOCWriter(signer)\nconst identifier = '0000000000000000000000000000000000000000000000000000000000000000'\nconst data = new Uint8Array([1, 2, 3])\nconst response = await socWriter.upload(postageBatchId, identifier, data)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"feeds",children:"Feeds"}),"\n",(0,a.jsx)(n.p,{children:"Feeds are an abstraction built on top of SOCs to provide mutable resources on the otherwise immutable data types that Swarm supports."}),"\n",(0,a.jsx)(n.p,{children:"One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated."}),"\n",(0,a.jsxs)(n.p,{children:["A feed is defined by its ",(0,a.jsx)(n.code,{children:"owner"})," (see above), a ",(0,a.jsx)(n.code,{children:"topic"})," (32 bytes arbitrary data as a hex string or ",(0,a.jsx)(n.code,{children:"Uint8Array"}),"), and a ",(0,a.jsx)(n.code,{children:"type"}),". ",(0,a.jsx)(n.code,{children:"type"})," defines how the updates and lookup of the feed index are made (currently only the ",(0,a.jsx)(n.code,{children:"sequence"})," type is supported)."]}),"\n",(0,a.jsx)(n.p,{children:"The publisher is the owner of the feed, and only they can post updates to the feed. Posting an update requires (1) constructing the identifier from the topic and the correct index and (2) signing it concatenated together with the hash of the arbitrary content of the update."}),"\n",(0,a.jsx)(n.p,{children:"Conversely, users can consume a feed by retrieving the chunk by its address. Retrieving an update requires the consumer to construct the address from the owner\u2019s address and the identifier. To calculate the identifier, they need the topic and the appropriate index. For this, they need to know the indexing scheme."}),"\n",(0,a.jsx)(n.p,{children:"Feeds enable Swarm users to represent a sequence of content updates. The content of the update is the payload that the feed owner signs against the identifier. The payload can be a swarm reference from which the user can retrieve the associated data."}),"\n",(0,a.jsx)(n.h3,{id:"topic",children:"Topic"}),"\n",(0,a.jsxs)(n.p,{children:["In Swarm, ",(0,a.jsx)(n.code,{children:"topic"})," is a 32-byte long arbitrary byte array. It's possible to choose an arbitrary topic for each application, and then knowing someone's (or something's) address, it's possible to find their feeds. Also, this can be the hash of a human-readable string, specifying the topic and optionally the subtopic of the feed. There is a helper function provided for that:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const topic = bee.makeFeedTopic('my-dapp.eth/outbox')\n"})}),"\n",(0,a.jsx)(n.h3,{id:"high-level-json-api",children:"High level JSON API"}),"\n",(0,a.jsx)(n.p,{children:"Many applications are storing or manipulating data in JSON. bee-js has convenience high level API to use feeds with JSON objects.\nIt consists of two methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"setJsonFeed"})," method to set JSON compatible data to feed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getJsonFeed"})," method to get JSON compatible data (and parse them) from feed"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Bee's instance signer",type:"info",children:(0,a.jsxs)(n.p,{children:["You can pass a ",(0,a.jsx)(n.code,{children:"Signer"})," (or compatible data) into ",(0,a.jsx)(n.code,{children:"Bee"})," class constructor, which then\nwill be used as default ",(0,a.jsx)(n.code,{children:"Signer"}),"."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const postageBatchId = await bee.createPostageBatch(\"100\", 17)\n\nawait bee.setJsonFeed(\n  postageBatchId,\n  'some cool arbitraty topic', \n  { some: ['cool', { json: 'compatible' }, 'object']}, \n  { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' }\n)\n\nconst data = await bee.getJsonFeed(\n  'some cool arbitraty topic', \n  { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' }\n)\n\nconsole.log(data)\n// Prints: { some: ['cool', { json: 'compatible' }, 'object']}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"low-level-api",children:"Low level API"}),"\n",(0,a.jsx)(n.p,{children:"Low level API is an API that is more flexible in its usage, but requires better understanding and mainly more method calls."}),"\n",(0,a.jsx)(n.h4,{id:"reading-feeds",children:"Reading feeds"}),"\n",(0,a.jsxs)(n.p,{children:["To read data from a feed, we need to make a reader object for a specific ",(0,a.jsx)(n.code,{children:"type"}),", ",(0,a.jsx)(n.code,{children:"topic"})," and ",(0,a.jsx)(n.code,{children:"owner"}),", then we can download the latest update containing a reference."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const topic = '0000000000000000000000000000000000000000000000000000000000000000'\nconst owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632'\nconst feedReader = bee.makeFeedReader('sequence', topic, owner)\nconst feedUpdate = await feedReader.download()\nconsole.log(feedUpdate.reference) // prints the latest reference stored in the feed\n"})}),"\n",(0,a.jsx)(n.h4,{id:"writing-feeds",children:"Writing feeds"}),"\n",(0,a.jsxs)(n.p,{children:["When writing a feed, typically an immutable content is uploaded first, and then its reference is updated in the feed. The ",(0,a.jsx)(n.code,{children:"signer"})," here is the same as with ",(0,a.jsx)(n.a,{href:"#writing-socs",children:"writing the SOCs"})," (with the same caveats!)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const postageBatchId = await bee.createPostageBatch(\"100\", 17)\nconst data = new Uint8Array([1, 2, 3])\nconst reference = await bee.uploadData(data)\nconst topic = '0000000000000000000000000000000000000000000000000000000000000000'\nconst signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd'\nconst feedWriter = bee.makeFeedWriter('sequence', topic, signer)\nconst response = await feedWriter.upload(postageBatchId, reference)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-feed-manifest",children:"Using feed manifest"}),"\n",(0,a.jsx)(n.p,{children:"One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated."}),"\n",(0,a.jsxs)(n.p,{children:['Swarm provides a feature called "feed manifests" for this use case. It is a content-addressed chunk that stores a feed\'s definition (the ',(0,a.jsx)(n.code,{children:"type"}),", the ",(0,a.jsx)(n.code,{children:"topic"}),", and the ",(0,a.jsx)(n.code,{children:"owner"}),"). When it is looked up using the ",(0,a.jsx)(n.code,{children:"bzz"})," endpoint, Swarm recognizes that it refers to a feed and continues the lookup according to the feed parameters."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const postageBatchId = await bee.createPostageBatch(\"100\", 17)\nconst topic = '0000000000000000000000000000000000000000000000000000000000000000'\nconst owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632'\nconst reference = bee.createFeedManifest(postageBatchId, 'sequence', topic, owner)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This creates the feed manifest chunk on Swarm. You can use the returned reference to look up with the ",(0,a.jsx)(n.code,{children:"/bzz"})," endpoint or use it with ENS."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);