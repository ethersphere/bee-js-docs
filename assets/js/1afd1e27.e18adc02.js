(self.webpackChunkbee_js_docs=self.webpackChunkbee_js_docs||[]).push([[7227],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=l(n),m=a,f=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(f,o(o({ref:t},c),{},{components:n})):r.createElement(f,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6503:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return l},default:function(){return u}});var r=n(2122),a=n(9756),i=(n(7294),n(3905)),o={id:"signer",title:"Type alias: Signer",sidebar_label:"Signer",sidebar_position:0,custom_edit_url:null},p=void 0,s={unversionedId:"api/types/signer",id:"api/types/signer",isDocsHomePage:!1,title:"Type alias: Signer",description:"\u01ac Signer: Object",source:"@site/docs/api/types/signer.md",sourceDirName:"api/types",slug:"/api/types/signer",permalink:"/docs/api/types/signer",editUrl:null,version:"current",sidebarPosition:0,frontMatter:{id:"signer",title:"Type alias: Signer",sidebar_label:"Signer",sidebar_position:0,custom_edit_url:null},sidebar:"Balls",previous:{title:"Signature",permalink:"/docs/api/types/signature"},next:{title:"Topic",permalink:"/docs/api/types/topic"}},l=[],c={toc:l};function u(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"\u01ac ",(0,i.kt)("strong",{parentName:"p"},"Signer"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")),(0,i.kt)("p",null,"Interface for implementing Ethereum compatible signing."),(0,i.kt)("p",null,"In order to be compatible with Ethereum and its signing method ",(0,i.kt)("inlineCode",{parentName:"p"},"personal_sign"),", the data\nthat are passed to sign() function should be prefixed with: ",(0,i.kt)("inlineCode",{parentName:"p"},"\\x19Ethereum Signed Message:\\n${data.length}"),", hashed\nand only then signed.\nIf you are wrapping another signer tool/library (like Metamask or some other Ethereum wallet), you might not have\nto do this prefixing manually if you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"personal_sign")," method. Check documentation of the tool!\nIf you are writing your own storage for keys, then you have to prefix the data manually otherwise the Bee node\nwill reject the chunks signed by you!"),(0,i.kt)("p",null,"For example see the hashWithEthereumPrefix() function."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"property"))," sign     The sign function that can be sync or async. This function takes non-prefixed data. See above."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"property"))," address  The ethereum address of the signer in bytes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"see"))," hashWithEthereumPrefix"),(0,i.kt)("h4",{id:"type-declaration"},"Type declaration"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"/docs/api/types/utils.eth.ethaddress"},(0,i.kt)("inlineCode",{parentName:"a"},"EthAddress")))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"sign")),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"SyncSigner")," ","|"," ",(0,i.kt)("inlineCode",{parentName:"td"},"AsyncSigner"))))),(0,i.kt)("h4",{id:"defined-in"},"Defined in"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethersphere/bee-js/blob/0e69ca1/src/types/index.ts#L414"},"bee-js/src/types/index.ts:414")))}u.isMDXComponent=!0}}]);